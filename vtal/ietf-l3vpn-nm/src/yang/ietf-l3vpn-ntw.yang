module ietf-l3vpn-ntw {
  yang-version 1.1;
  namespace "urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw";
  prefix l3vpn-ntw;

  // NSO ADDITION START
  import custom-template-hook { prefix ct-hook; }
  import tailf-kicker { prefix kicker; }
  import tailf-common { prefix tailf; }
  import tailf-ncs { prefix ncs; }
  import lsa-utils { prefix lsa-utils; }
  import cisco-tsdn-core-fp-common { prefix tsdn-core-fp-common; }
  // NSO ADDITION END

  import ietf-inet-types {
    prefix inet;
    reference
      "Section 4 of RFC 6991";
  }
  import ietf-yang-types {
    prefix yang;
    reference
      "Section 3 of RFC 6991";
  }
  import ietf-netconf-acm {
    prefix nacm;
    reference
      "RFC 8341: Network Configuration Access Control Model";
  }
  import ietf-routing-types {
    prefix rt-types;
    reference
      "RFC 8294: Common YANG Data Types for the Routing Area";
  }
  import ietf-l3vpn-svc {
    prefix l3vpn-svc;
    reference
      "RFC 8299: YANG Data Model for L3VPN Service Delivery";
  }
  import ietf-packet-fields {
    prefix packet-fields;
    reference
      "RFC 8519: YANG Data Model for Network Access
                 Control Lists (ACLs)";
  }

  organization
    "IETF OPSA (Operations and Management Area) Working Group ";
  contact
    "WG Web:   <http://tools.ietf.org/wg/opsawg/>
        WG List:  <mailto:opsawg@ietf.org>
        Author:    Samier Barguil
                  <mailto:samier.barguilgiraldo.ext@telefonica.com>
        Editor:    Oscar Gonzalez de Dios
                  <mailto:oscar.gonzalezdedios@telefonica.com>
        Author:   Mohamed Boucadair
                  <mailto:mohamed.boucadair@orange.com>
        Author:    Luis Angel Munoz
                  <mailto:luis-angel.munoz@vodafone.com>
        Author:    Alejandro Aguado
                  <mailto:alejandro.aguado_martin@nokia.com>
    ";
  description
    "This YANG module defines a generic network-oriented model
     for the configuration of Layer 3 Virtual Private Networks.
     Copyright (c) 2020 IETF Trust and the persons identified as
     authors of the code.  All rights reserved.

     Redistribution and use in source and binary forms, with or
     without modification, is permitted pursuant to, and subject to
     the license terms contained in, the Simplified BSD License set
     forth in Section 4.c of the IETF Trust's Legal Provisions
     Relating to IETF Documents
     (https://trustee.ietf.org/license-info).

     This version of this YANG module is part of RFC XXXX
     (https://www.rfc-editor.org/info/rfcXXXX); see the RFC itself
     for full legal notices.";

  revision 2022-05-26 {
    description
      "Modified: cvlan-id range to 1..4094";
  }

  revision 2021-12-03 {
	description
	  "Removed: core-fp-common reference
	   Modified: Read dispatch-map using lsa-utils";
  }

  revision 2021-09-16 {
    description "Updated: description and tailf:info for grouping vpn-route-targets
                          -> vpn-target -> id";
  }

  revision 2021-08-06 {
    description
      "Added: tsdn-core-fp-common static-config-redeploy-indicator-component-augmentation
              grouping to plan component augment
       Added: tsdn-core-fp-common static-config-redeploy-indicator-component-augmentation
              grouping to plan-history component augment";
  }
  revision 2021-08-05 {
    description "Modified: Changed static-addresses, dot1q-vlan-tagged, tagged-interface to
                           presence containers";
  }

  revision 2021-07-09 {
    description "Added: when check for cvlan-id for port-id Loopback / BVI";
  }

  revision 2021-06-16 {
    description "Modified: Updated operational status name and description";
  }

  revision 2021-05-18 {
    description "Removed: 'uses tsdn-core-fp-common:service-assurance-grouping'
                           under vpn-services -> vpn-service";
  }

  revision 2021-05-11 {
    description
    "Modified: augment l3vpn->plan to use tsdn-core-fp-common:status-code-plan-augmentation";
  }

  revision 2021-05-10 {
    description "Modified: typedef operational-type";
  }

  revision 2021-04-30 {
    description "Allowed: vpn-services -> vpn-service -> service-status (oper-data)";
  }

  revision 2021-04-01 {
    description "Added: vpn-services -> vpn-service -> service-assurance-grouping";
  }

  revision 2021-03-31 {
    description "Added: l3vpn-ntw->vpn-services->vpn-service->vpn-nodes->vpn-node
                  ->vpn-network-accesses->vpn-network-access->connection
                  when '../encapsulation-type='l3vpn-ntw:tagged-int'";
  }

  revision 2021-03-30 {
    description "Updated: leafref for l3vpn-ntw->vpn-services->vpn-service->vpn-nodes->vpn-node
                          -> node-ie-profile";

  }

  revision 2021-03-24 {
    description "Removed: l3vpn-ntw->vpn-services->vpn-service->vpn-nodes->vpn-node
                 ->vpn-network-accesses->vpn-network-access->connection->tagged-interface
                 ->dot1q-vlan-tagged->cvlan-id mandatory from yang
                 and added deviation mandatory true for it";
  }

  revision 2021-03-19 {
    description "Removed: vpn-nodes -> vpn-node -> vpn-network-accesses -> vpn-netowrk-access ->
                          routing-protocols -> routing-protocol -> bgp -> local-autonomous-system";
  }

  revision 2021-03-16 {
    description "Modified: l3vpn-ntw->vpn-services->vpn-service->vpn-nodes->vpn-node
                 ->vpn-network-accesses->vpn-network-access->connection->tagged-interface
                 ->dot1q-vlan-tagged->cvlan-id is now mandatory";
  }

  revision 2021-03-11 {
    description "Modified: Changed static-address -> primary-address to reference local address
                 list instead of global";
  }

  revision 2021-02-15 {
    description "Modified: tailf:info for site-routing->routing-protocol";
  }

  revision 2021-02-15 {
    description "Removed: All unused groupings";
  }

  revision 2021-01-27 {
    description "Removed: Unused elements containing tailf:hidden full";
  }

  revision 2020-11-16 {
    description "Added validate callpoint to service";
  }

  revision 2020-11-13 {
    description "Added: vpn-network-access-id input for cleanup action
                 Added: leaf sync-direction as mandatory input to error-recovery action
                 Added: Update-source container for router->bgp.
                 Added: mpls-deactivation for router->ebgp-multihop->mpls-deactivation;";
  }

  revision 2020-11-05 {
    description "Added: When condition to BDI, to allow only when device is XE";
  }

  revision 2020-10-26 {
    description "Modified : redistribute-connected-ipv4-af is now presence container with metric
                 Modified : redistribute-connected-ipv6-af is now presence container with metric
                 Added : dot1q -> BDI leaf";
  }

  revision 2020-10-21 {
    description "Added : redistribute-connected-ipv4-af empty leaf under bgp
                 Added : redistribute-connected-ipv6-af empty leaf under bgp
                 Modified : Service/vpn-node level error recovery has new input field
                            'vpn-network-access-id'";
  }

  revision 2020-10-18 {
    description
      "Added: import cisco-flat-L3vpn-fp for referencing l3vpn-route-policy
       Modified: Hide routing-profiles
       Modified: Unhide import-policy";
  }

  revision 2020-04-03 {
    description
      "Initial revision.";
    reference
      "RFC XXXX: A Layer 3 VPN Network YANG Model";
      // RFC Ed.: replace XXXX with actual RFC number and remove
     // this note
  }

  /* Features */

  feature msdp {
    description
      "This feature indicates that msdp capabilities
       are supported by the VPN.";
  }

  feature rtg-isis {
    description
      "This features indicates the support of the ISIS
       routing protocol.";
  }

  feature rtg-ospf-sham-link {
    description
      "This feature indicates the support of OSPF sham links.";
  }

  feature input-bw {
    description
      "This feature indicates the support of
       the 'input-bw' limit.";
  }

  feature dot1q {
    description
      "This feature indicates the support of
       the 'dot1q' encapsulation.";
  }

  feature qinq {
    description
      "This feature indicates the support of
       the 'qinq' encapsulation.";
  }

  feature qinany {
    description
      "This feature indicates the support of
       the 'qinany' encapsulation.";
  }

  feature vxlan {
    description
      "This feature indicates the support of
       the 'vxlan' encapsulation.";
  }

  /* Typedefs */

  typedef protocol-type {
    type enumeration {
      enum GRE {
        value 0;
        description
          "Transport based on GRE.";
      }
      enum LDP {
        value 1;
        description
          "Transport based on LDP.";
      }
      enum BGP {
        value 2;
        description
          "Transport based on BGP.";
      }
      enum SR {
        value 3;
        description
          "Transport based on Segment Routing (SR)";
      }
      enum SR-TE {
        value 4;
        description
          "Transport based on SR for Traffic Engineering.";
      }
      enum RSVP-TE {
        value 5;
        description
          "Transport based on RSVP for Traffic Engineering";
      }
      enum unknown {
        value 6;
        description
          "Transport UNKNOWN";
      }
    }
    description
      "These attributes are used to identify underlying
       protocols when activating an L3VPN service.";
  }

  typedef area-address {
    type string {
      pattern '[0-9A-Fa-f]{2}(\.[0-9A-Fa-f]{4}){0,6}';
    }
    description
      "This type defines the area address format.";
  }

  typedef isis-level {
    type enumeration {
      enum level1 {
        value 0;
        description
          "ISIS level 1";
      }
      enum level2 {
        value 1;
        description
          "ISIS level 2";
      }
      enum level1-2 {
        value 2;
        description
          "ISIS level 1 and 2";
      }
    }
    description
      "Defines the ISIS level for interface and system.";
  }

  typedef ie-type {
    type enumeration {
      enum import {
        value 0;
        description
          "Import a routing profile.";
      }
      enum export {
        value 1;
        description
          "Export a routing profile.";
      }
      enum both {
        value 2;
        description
          "Import/Export a routing profile.";
      }
    }
    description
      "Defines Import-Export routing profiles.
       Those profiles can be reused between VPN nodes.";
  }

  typedef operational-type {
    type enumeration {
      enum up {
        value 0;
        description
          "Operational status UP/Enabled.";
      }
      enum down {
        value 1;
        description
          "Operational status DOWN/Disabled.";
      }
      enum unknown {
        value 2;
        description
          "Operational status UNKNOWN.";
      }
      // NSO ADDITION START
      enum operational-state-degraded {
        value 3;
        description
          "Service Health is degraded due to one or more parts being monitored
          has issues.";
      }
      enum operational-state-monitor-paused {
        value 4;
        description
          "Service Assurance monitoring is paused.";
      }
      enum operational-state-monitor-initiated {
        value 5;
        description
          "Service Assurance monitoring is being initiated.";
      }
      enum operational-state-monitor-failed {
        value 6;
        description
          "Service Assurance monitoring encountered failure.";
      }
      // NSO ADDITION END
    }
    description
      "This attribute is used to determine the
       status of a particular element.";
  }

  /* Identities */

  identity vpn-topology {
    description
      "Base identity for VPN topology.";
  }

  identity any-to-any {
    base vpn-topology;
    description
      "Identity for any-to-any VPN topology.";
  }

  identity hub-spoke {
    base vpn-topology;
    description
      "Identity for Hub-and-Spoke VPN topology.";
  }

  identity hub-spoke-disjoint {
    base vpn-topology;
    description
      "Identity for Hub-and-Spoke VPN topology
       where Hubs cannot communicate with each other.";
  }

  identity custom {
    base vpn-topology;
    description
      "Identity for CUSTOM VPN topology
       where Hubs can act as Spoke for certain part of
       the network or Spokes as Hubs.";
  }

  // NSO-REMOVED START
  // identity isis {
  //   base l3vpn-svc:routing-protocol-type;
  //   description
  //     "Identity for ISIS protocol type.";
  // }
  // NSO-REMOVED END

  identity pseudowire {
    base l3vpn-svc:site-network-access-type;
    description
      "Identity for pseudowire connections.";
  }

  identity loopback {
    base l3vpn-svc:site-network-access-type;
    description
      "Identity for loopback connections.";
  }

  identity encapsulation-type {
    description
      "Identity for the encapsulation type.";
  }

  identity untagged-int {
    base encapsulation-type;
    description
      "Identity for Ethernet type.";
  }

  identity tagged-int {
    base encapsulation-type;
    description
      "Identity for the VLAN type.";
  }

  identity eth-inf-type {
    description
      "Identity of the Ethernet interface type.";
  }

  identity tagged {
    base eth-inf-type;
    description
      "Identity of the tagged interface type.";
  }

  identity untagged {
    base eth-inf-type;
    description
      "Identity of the untagged interface type.";
  }

  identity lag {
    base eth-inf-type;
    description
      "Identity of the LAG interface type.";
  }

  identity bearer-inf-type {
    description
      "Identity for the bearer interface type.";
  }

  identity port-id {
    base bearer-inf-type;
    description
      "Identity for the priority-tagged interface.";
  }

  identity lag-id {
    base bearer-inf-type;
    description
      "Identity for the priority-tagged interface.";
  }

  identity tagged-inf-type {
    description
      "Identity for the tagged interface type.";
  }

  identity priority-tagged {
    base tagged-inf-type;
    description
      "Identity for the priority-tagged interface.";
  }

  // NSO-REMOVED START
  // identity qinq {
  //   base tagged-inf-type;
  //   description
  //     "Identity for the QinQ tagged interface.";
  // }
  // NSO-REMOVED END

  identity dot1q {
    base tagged-inf-type;
    description
      "Identity for the dot1Q VLAN tagged interface.";
  }

  // NSO-REMOVED START
  // identity qinany {
  //   base tagged-inf-type;
  //   description
  //     "Identity for the QinAny tagged interface.";
  // }

  // identity vxlan {
  //   base tagged-inf-type;
  //   description
  //     "Identity for the VXLAN tagged interface.";
  // }
  // NSO-REMOVED END

  identity tag-type {
    description
      "Base identity from which all tag types are derived.";
  }

  identity c-vlan {
    base tag-type;
    description
      "A CVLAN tag, normally using the 0x8100 Ethertype.";
  }

  identity s-vlan {
    base tag-type;
    description
      "An SVLAN tag.";
  }

  identity c-s-vlan {
    base tag-type;
    description
      "Using both a CVLAN tag and an SVLAN tag.";
  }

  identity vxlan-peer-mode {
    description
      "Base identity for the VXLAN peer mode.";
  }

  identity static-mode {
    base vxlan-peer-mode;
    description
      "Identity for VXLAN access in the static mode.";
  }

  identity bgp-mode {
    base vxlan-peer-mode;
    description
      "Identity for VXLAN access using BGP EVPN.";
  }

  identity bw-direction {
    description
      "Identity for the bandwidth direction.";
  }

  identity input-bw {
    base bw-direction;
    description
      "Identity for the input bandwidth.";
  }

  identity output-bw {
    base bw-direction;
    description
      "Identity for the output bandwidth.";
  }

  identity bw-type {
    description
      "Identity of the bandwidth type.";
  }

  identity bw-per-cos {
    base bw-type;
    description
      "Bandwidth is per CoS.";
  }

  identity bw-per-port {
    base bw-type;
    description
      "Bandwidth is per site network access.";
  }

  identity bw-per-site {
    base bw-type;
    description
      "Bandwidth is per site.  It is applicable to
       all the site network accesses within a site.";
  }

  identity bw-per-svc {
    base bw-type;
    description
      "Bandwidth is per VPN service.";
  }

  /* Groupings */
  // NSO-REMOVED START
  // grouping svc-transport-encapsulation {
  //   container underlay-transport {
  //     leaf-list type {
  //       type protocol-type;
  // ordered-by user;
  //       description
  //         "Protocols used to deliver an L3VPN service.";
  //     }
  //     description
  //       "Container for the Transport Underlay.";
  //   }
  //   description
  //     "This grouping defines the type of underlay transport
  //   for VPN service.";
  // }
  //
  // grouping multicast-rp-group-cfg {
  //   choice group-format {
  //     mandatory true;
  //     case group-prefix {
  //       leaf group-address {
  //         type inet:ip-prefix;
  //         description
  //           "A single multicast group prefix.";
  //       }
  //     }
  //     case startend {
  //       leaf group-start {
  //         type inet:ip-address;
  //         description
  //           "The first multicast group address in
  //            the multicast group address range.";
  //       }
  //       leaf group-end {
  //         type inet:ip-address;
  //         description
  //           "The last multicast group address in
  //            the multicast group address range.";
  //       }
  //     }
  //     description
  //       "Choice for multicast group format.";
  //   }
  //   description
  //     "This grouping defines multicast group or
  //      multicast groups for RP-to-group mapping.";
  // }
  //
  // grouping vpn-service-multicast {
  //   container multicast {
  //     if-feature "l3vpn-svc:multicast";
  //     leaf enabled {
  //       type boolean;
  //       default "false";
  //       description
  //         "Enables multicast.";
  //     }
  //     leaf-list tree-flavor {
  //       type identityref {
  //         base l3vpn-svc:multicast-tree-type;
  //       }
  //       description
  //         "Type of tree to be used.";
  //     }
  //     container rp {
  //       container rp-group-mappings {
  //         list rp-group-mapping {
  //           key "id";
  //           leaf id {
  //             type uint16;
  //             description
  //               "Unique identifier for the mapping.";
  //           }
  //           container provider-managed {
  //             leaf enabled {
  //               type boolean;
  //               default "false";
  //               description
  //                 "Set to true if the Rendezvous Point (RP)
  //                  must be a provider-managed node.  Set to false
  //                  if it is a customer-managed node.";
  //             }
  //             leaf rp-redundancy {
  //               type boolean;
  //               default "false";
  //               description
  //                 "If true, a redundancy mechanism for the RP
  //                  is required.";
  //             }
  //             leaf optimal-traffic-delivery {
  //               type boolean;
  //               default "false";
  //               description
  //                 "If true, the SP must ensure that
  //                  traffic uses an optimal path.  An SP may use
  //                  Anycast RP or RP-tree-to-SPT switchover
  //                  architectures.";
  //             }
  //             container anycast {
  //               when "../rp-redundancy = 'true' and
  //                     ../optimal-traffic-delivery = 'true'" {
  //                   description
  //                     "Only applicable if
  //                      RP redundancy is
  //                      enabled and delivery through
  //                      optimal path is activated.";
  //               }
  //               leaf local-address {
  //                 type inet:ip-address;
  //                 description
  //                   "IP local address for PIM RP.
  //                    Usually, it corresponds to router
  //                    ID or primary address";
  //               }
  //               leaf-list rp-set-address {
  //                 type inet:ip-address;
  //                 description
  //                   "Address other RP routers
  //                    that share the same RP IP address.";
  //               }
  //               description
  //                 "PIM Anycast-RP parameters.";
  //             }
  //             description
  //               "Parameters for a provider-managed RP.";
  //           }
  //           leaf rp-address {
  //             when "../provider-managed/enabled = 'false'" {
  //               description
  //                 "Relevant when the RP is not provider-managed.";
  //             }
  //             type inet:ip-address;
  //             mandatory true;
  //             description
  //               "Defines the address of the RP.
  //                Used if the RP is customer-managed.";
  //           }
  //           container groups {
  //             list group {
  //               key "id";
  //               leaf id {
  //                 type uint16;
  //                 description
  //                   "Identifier for the group.";
  //               }
  //               uses multicast-rp-group-cfg;
  //               description
  //                 "List of multicast groups.";
  //             }
  //             description
  //               "Multicast groups associated with the RP.";
  //           }
  //           description
  //             "List of RP-to-group mappings.";
  //         }
  //         description
  //           "RP-to-group mappings parameters.";
  //       }
  //       container rp-discovery {
  //         leaf rp-discovery-type {
  //           type identityref {
  //             base l3vpn-svc:multicast-rp-discovery-type;
  //           }
  //           default "l3vpn-svc:static-rp";
  //           description
  //             "Type of RP discovery used.";
  //         }
  //         container bsr-candidates {
  //           when "derived-from-or-self(../rp-discovery-type, "
  //              + "'l3vpn-svc:bsr-rp')" {
  //             description
  //               "Only applicable if discovery type
  //                is BSR-RP.";
  //           }
  //           leaf-list bsr-candidate-address {
  //             type inet:ip-address;
  //             description
  //               "Address of candidate Bootstrap Router (BSR).";
  //           }
  //           description
  //             "Container for List of Customer
  //              BSR candidate's addresses.";
  //         }
  //         description
  //           "RP discovery parameters.";
  //       }
  //       description
  //         "RP parameters.";
  //     }
  //     container msdp {
  //       if-feature "msdp";
  //       leaf enabled {
  //         type boolean;
  //         default "false";
  //         description
  //           "If true, Multicast Source Discovery Protocol (MSDP)
  //            protocol is activated.";
  //       }
  //       leaf peer {
  //         type inet:ip-address;
  //         description
  //           "IP address of the MSDP peer.";
  //       }
  //       leaf local-address {
  //         type inet:ip-address;
  //         description
  //           "IP address of the local end. This local address
  //            must be configured on the node.";
  //       }
  //       description
  //         "MSDP parameters.";
  //     }
  //     description
  //       "Multicast global parameters for the VPN service.";
  //   }
  //   description
  //     "Grouping for multicast VPN definition.";
  // }
  //
  // grouping vpn-service-mpls {
  //   leaf carrierscarrier {
  //     if-feature "l3vpn-svc:carrierscarrier";
  //     type boolean;
  //     default "false";
  //     description
  //       "The VPN is using CsC, and so MPLS is required.";
  //   }
  //   description
  //     "Grouping for MPLS Carriers'Carrier definition.";
  // }
  //
  // grouping operational-requirements {
  //   leaf requested-site-start {
  //     type yang:date-and-time;
  //     description
  //       "Optional leaf indicating requested date and
  //        time when the service at a particular site is
  //        expected to start.";
  //   }
  //   leaf requested-site-stop {
  //     type yang:date-and-time;
  //     description
  //       "Optional leaf indicating requested date and
  //        time when the service at a particular site is
  //        expected to stop.";
  //   }
  //   description
  //     "This grouping defines some operational
  //      parameters.";
  // }
  //
  grouping status-timestamp {
    leaf status {
      type operational-type;
      description
        "Operations status";
      tailf:info "Operations status";
    }
    leaf timestamp {
      type yang:date-and-time;
      description
        "Indicates the actual date and time when
         the service actually started (UP) or
         stopped (DOWN).";
      tailf:info "Indicates the actual date and time when
         the service actually started (UP) or
         stopped (DOWN).";
    }
    description
      "This grouping defines some operational
       parameters for the service.";
  }

  grouping service-status {
    container service-status {
  //     container admin {
  //       uses status-timestamp;
  //       description
  //         "Administrative service status.";
  //     }
      container ops {
        config false;
        uses status-timestamp;
        description
          "Operational service status.";
        tailf:info "Operational service status.";
      }
      description
        "Service status.";
      tailf:info "Service status.";
    }
    description
      "Service status grouping. Reused in
       vpn-node and vpn-network-access.";
  }
  //
  // grouping site-service-basic {
  //   leaf svc-input-bandwidth {
  //     type uint64;
  //     units "bps";
  //     mandatory true;
  //     description
  //       "From the customer site's perspective, the service
  //        input bandwidth of the connection or download
  //        bandwidth from the SP to the site.";
  //     tailf:info "From the customer site's perspective, the service
  //        input bandwidth of the connection or download
  //        bandwidth from the SP to the site";
  //   }
  //   leaf svc-output-bandwidth {
  //     type uint64;
  //     units "bps";
  //     mandatory true;
  //     description
  //       "From the customer site's perspective, the service
  //        output bandwidth of the connection or upload
  //        bandwidth from the site to the SP.";
  //     tailf:info "From the customer site's perspective, the service
  //        output bandwidth of the connection or upload
  //        bandwidth from the site to the SP.";
  //   }
  //   leaf svc-mtu {
  //     type uint16;
  //     units "bytes";
  //     mandatory true;
  //     description
  //       "MTU at service level.  If the service is IP,
  //        it refers to the IP MTU.  If CsC is enabled,
  //        the requested 'svc-mtu' leaf will refer to the
  //        MPLS MTU and not to the IP MTU.";
  //     tailf:info "MTU at service level.  If the service is IP,
  //        it refers to the IP MTU.  If CsC is enabled,
  //        the requested 'svc-mtu' leaf will refer to the
  //        MPLS MTU and not to the IP MTU.";
  //   }
  //   description
  //     "Defines basic service parameters for a site.";
  // }
  //
  // grouping site-protection {
  //   container traffic-protection {
  //     if-feature "l3vpn-svc:fast-reroute";
  //     leaf enabled {
  //       type boolean;
  //       default "false";
  //       description
  //         "Enables traffic protection of access link.";
  //     }
  //     description
  //       "Fast Reroute service parameters for the site.";
  //   }
  //   description
  //     "Defines protection service parameters for a site.";
  // }
  // grouping site-service-mpls {
  //   container carrierscarrier {
  //     if-feature "l3vpn-svc:carrierscarrier";
  //     leaf signalling-type {
  //       type enumeration {
  //         enum ldp {
  //           description
  //             "Use LDP as the signalling protocol
  //              between the PE and the CE.  In this case,
  //              an IGP routing protocol must also be activated.";
  //         }
  //         enum bgp {
  //           description
  //             "Use BGP as the signalling protocol
  //              between the PE and the CE.
  //              In this case, BGP must also be configured as
  //              the routing protocol.";
  //           reference
  //             "RFC 8277: Using BGP to Bind MPLS Labels to
  //                        Address Prefixes";
  //         }
  //       }
  //       default "bgp";
  //       description
  //         "MPLS signalling type.";
  //     }
  //     description
  //       "This container is used when the customer provides
  //        MPLS-based services.  This is only used in the case
  //        of CsC (i.e., a customer builds an MPLS service using
  //        an IP VPN to carry its traffic).";
  //   }
  //   description
  //     "Defines MPLS service parameters for a site.";
  // }
  //
  // grouping ports {
  //   choice source-port {
  //     container source-port-range-or-operator {
  //       uses packet-fields:port-range-or-operator;
  //       description
  //         "Source port definition.";
  //     }
  //     description
  //       "Choice of specifying the source port or referring to
  //        a group of source port numbers.";
  //   }
  //   choice destination-port {
  //     container destination-port-range-or-operator {
  //       uses packet-fields:port-range-or-operator;
  //       description
  //         "Destination port definition.";
  //     }
  //     description
  //       "Choice of specifying a destination port or referring
  //        to a group of destination port numbers.";
  //   }
  //   description
  //     "Choice of specifying a source or destination port numbers.";
  // }
  //
  // grouping site-service-qos-profile {
  //   container qos {
  //     if-feature "l3vpn-svc:qos";
  //     container qos-classification-policy {
  //       list rule {
  //         key "id";
  //         ordered-by user;
  //         leaf id {
  //           type string;
  //           description
  //             "A description identifying the
  //              qos-classification-policy rule.";
  //         }
  //         choice match-type {
  //           default "match-flow";
  //           case match-flow {
  //             uses l3vpn-svc:flow-definition;
  //             choice l3 {
  //               container ipv4 {
  //                 uses packet-fields:acl-ip-header-fields;
  //                 uses packet-fields:acl-ipv4-header-fields;
  //                 description
  //                   "Rule set that matches IPv4 header.";
  //               }
  //               container ipv6 {
  //                 uses packet-fields:acl-ip-header-fields;
  //                 uses packet-fields:acl-ipv6-header-fields;
  //                 description
  //                   "Rule set that matches IPv6 header.";
  //               }
  //               description
  //                 "Either IPv4 or IPv6.";
  //             }
  //             choice l4 {
  //               container tcp {
  //                 uses packet-fields:acl-tcp-header-fields;
  //                 uses ports;
  //                 description
  //                   "Rule set that matches TCP header.";
  //               }
  //               container udp {
  //                 uses packet-fields:acl-udp-header-fields;
  //                 uses ports;
  //                 description
  //                   "Rule set that matches UDP header.";
  //               }
  //               description
  //                 "Can be TCP or UDP";
  //             }
  //           }
  //           case match-application {
  //             leaf match-application {
  //               type identityref {
  //                 base l3vpn-svc:customer-application;
  //               }
  //               description
  //                 "Defines the application to match.";
  //             }
  //           }
  //           description
  //             "Choice for classification.";
  //         }
  //         leaf target-class-id {
  //           type string;
  //           description
  //             "Identification of the class of service.
  //              This identifier is internal to the administration.";
  //         }
  //         description
  //           "List of marking rules.";
  //       }
  //       description
  //         "Configuration of the traffic classification policy.";
  //     }
  //     container qos-profile {
  //       list qos-profile {
  //         key profile;
  //         description
  //           "QoS profile.
  //            Can be standard profile or customized profile.";
  //           leaf profile {
  //             type leafref {
  //               path "/l3vpn-ntw/vpn-profiles/"
  //                  + "valid-provider-identifiers"
  //                  + "/qos-profile-identifier/id";
  //             }
  //             description
  //               "QoS profile to be used.";
  //           }
  //           leaf direction {
  //             type identityref {
  //               base l3vpn-svc:qos-profile-direction;
  //             }
  //             default "l3vpn-svc:both";
  //             description
  //               "The direction to which the QoS profile
  //                is applied.";
  //           }
  //       }
  //       description
  //         "QoS profile configuration.";
  //     }
  //     description
  //       "QoS configuration.";
  //   }
  //   description
  //     "This grouping defines QoS parameters for a site.";
  // }
  //
  // grouping site-security-authentication {
  //   container authentication {
  //     description
  //       "Authentication parameters.";
  //   }
  //   description
  //     "This grouping defines authentication parameters
  //      for a site.";
  // }
  //
  // grouping site-security-encryption {
  //   container encryption {
  //     if-feature "l3vpn-svc:encryption";
  //     leaf enabled {
  //       type boolean;
  //       default "false";
  //       description
  //         "If true, traffic encryption on the connection
  //          is required. It is disabled, otherwise.";
  //     }
  //     leaf layer {
  //       when "../enabled = 'true'" {
  //         description
  //           "Require a value for layer when enabled
  //            is true.";
  //       }
  //       type enumeration {
  //         enum layer2 {
  //           description
  //             "Encryption will occur at Layer 2.";
  //         }
  //         enum layer3 {
  //           description
  //             "Encryption will occur at Layer 3.
  //              For example, IPsec may be used when
  //              a customer requests Layer 3 encryption.";
  //         }
  //       }
  //       description
  //         "Layer on which encryption is applied.";
  //     }
  //     description
  //       "Container for CE-PE security encryption.";
  //   }
  //   container encryption-profile {
  //     choice profile {
  //       case provider-profile {
  //         leaf profile-name {
  //           type leafref {
  //             path "/l3vpn-ntw/vpn-profiles/"
  //                + "valid-provider-identifiers"
  //                + "/encryption-profile-identifier/id";
  //           }
  //           description
  //             "Name of the SP profile to be applied.";
  //         }
  //       }
  //       case customer-profile {
  //         leaf algorithm {
  //           type string;
  //           description
  //             "Encryption algorithm to be used.";
  //         }
  //       }
  //       description
  //         "Choice for encryption profile.";
  //     }
  //     choice key-type {
  //       default "psk";
  //       case psk {
  //         leaf preshared-key {
  //           type string;
  //           description
  //             "Pre-Shared Key (PSK) coming from the customer.";
  //         }
  //       }
  //       description
  //         "Choice of encryption profile.
  //          The encryption profile can be the provider profile
  //          or customer profile.";
  //     }
  //     description
  //       "Container for encryption profile.";
  //   }
  //   description
  //     "This grouping defines encryption parameters for
  //        a site.";
  // }
  // NSO-REMOVED END

  grouping site-routing {
    container routing-protocols {
      list routing-protocol {
        key "id";
        leaf id {
          type string;
          description
            "Unique identifier for routing protocol. Only one routing protocol entry can be created per service's VPN node.";
          tailf:info
            "Unique identifier for routing protocol. Only one routing protocol entry can be created per service's VPN node.";
        }
        leaf type {
          type identityref {
            base l3vpn-svc:routing-protocol-type;
          }
          description
            "Type of routing protocol.";
          tailf:info
            "Type of routing protocol.";
        }
        // NSO-REMOVED START
        // list routing-profiles {
        //   key "id";
        //   leaf id {
        //     type leafref {
        //       path "/l3vpn-ntw/vpn-profiles/"
        //          + "valid-provider-identifiers"
        //          + "/routing-profile-identifier/id";
        //     }
        //     description
        //       "Routing profile to be used.";
        //     tailf:info
        //       "Routing profile to be used.";
        //   }
        //   leaf type {
        //     type ie-type;
        //     description
        //       "Import, export or both.";
        //     tailf:info
        //       "Import, export or both.";
        //   }
        //   description
        //     "Import or Export profile reference";
        // }
        // container ospf {
        //   when "derived-from-or-self(../type, 'l3vpn-svc:ospf')" {
        //     description
        //       "Only applies when protocol is OSPF.";
        //   }
        //   if-feature "l3vpn-svc:rtg-ospf";
        //   leaf-list address-family {
        //     type l3vpn-svc:address-family;
        //     min-elements 1;
        //     description
        //       "If OSPF is used on this site, this node
        //        contains a configured value.  This node
        //        contains at least one address family
        //        to be activated.";
        //   }
        //   leaf area-address {
        //     type yang:dotted-quad;
        //     mandatory true;
        //     description
        //       "Area address.";
        //   }
        //   leaf metric {
        //     type uint16;
        //     default "1";
        //     description
        //       "Metric of the PE-CE link.  It is used
        //        in the routing state calculation and
        //        path selection.";
        //   }
        //   // Extension
        //   leaf mtu {
        //     type uint16;
        //     description
        //       "Maximum transmission unit for a given
        //        OSPF link.";
        //   }
        //   leaf process-id {
        //     type uint16;
        //     description
        //       "Process id of the OSPF CE-PE connection.";
        //   }
        //   uses security-params;
        //   // End of Extension
        //   container sham-links {
        //     if-feature "rtg-ospf-sham-link";
        //     list sham-link {
        //       key "target-site";
        //       leaf target-site {
        //         type l3vpn-svc:svc-id;
        //         description
        //           "Target site for the sham link connection.
        //            The site is referred to by its ID.";
        //       }
        //       leaf metric {
        //         type uint16;
        //         default "1";
        //         description
        //           "Metric of the sham link.  It is used in
        //            the routing state calculation and path
        //            selection.  The default value is set
        //            to 1.";
        //       }
        //       description
        //         "Creates a sham link with another site.";
        //     }
        //     description
        //       "List of sham links.";
        //   }
        //   description
        //     "OSPF-specific configuration.";
        // }
        // NSO-REMOVED END
        container bgp {
          when "derived-from-or-self(../type, 'l3vpn-svc:bgp')" {
            description
              "Only applies when protocol is BGP.";
          }
          if-feature "l3vpn-svc:rtg-bgp";
          leaf peer-autonomous-system {
            type inet:as-number;
            mandatory true;
            description
              "Customer AS number in case the customer
               requests BGP routing.";
            tailf:info
              "Customer AS number in case the customer
               requests BGP routing.";
          }
          // NSO-REMOVED START
          //leaf local-autonomous-system {
          //  type inet:as-number;
          //  description
          //    "Local-AS overwrite.";
          //  tailf:info
          //    "Local-AS overwrite.";
          //}
          // NSO-REMOVED END
          leaf-list address-family {
            type l3vpn-svc:address-family;
            min-elements 1;
            description
              "If BGP is used on this site, this node
               contains a configured value.  This node
               contains at least one address family
               to be activated.";
            tailf:info
              "If BGP is used on this site, this node
               contains a configured value.  This node
               contains at least one address family
               to be activated.";
          }
          // NSO ADDITION START
          container redistribute-connected-ipv4-af {
            presence "true";
            tailf:info "Redistribute Connected ipv4";
            description "Redistribute Connected ipv4";
            leaf metric {
              tailf:info "Default metric <0..4294967295>";
              description "Default metric <0..4294967295>";
              type uint32 {
                range "0..4294967295";
              }
            }
          }
          container redistribute-connected-ipv6-af {
            presence "true";
            tailf:info "Redistribute Connected ipv6";
            description "Redistribute Connected ipv6";
            leaf metric {
              tailf:info "Default metric <0..4294967295>";
              description "Default metric <0..4294967295>";
              type uint32 {
                range "0..4294967295";
              }
            }
          }
          container update-source {
            presence "true";
            tailf:info "Source of routing updates";
            description "Source of routing updates";
            leaf if-type {
              when "not(contains(/ncs:devices/lsa-utils:lsa/lsa-utils:dispatch-map/lsa-utils:device
                  [lsa-utils:name=current()/../../../../../../../ne-id]/lsa-utils:ned-id,
                  'cisco-ios-cli-'))
                  or
                  not(../../../../../connection/tagged-interface/dot1q-vlan-tagged/BDI)";
              tailf:info "Interface Type";
              description "Interface Type";
              type enumeration {
                enum Bundle-Ether;
                enum Ethernet;
                enum FiftyGigE;
                enum FortyGigE;
                enum FourHundredGigE;
                enum GigabitEthernet;
                enum HundredGigE;
                enum Loopback;
                enum TenGigE;
                enum TwentyFiveGigE;
                enum TwoHundredGigE;
              }
              mandatory true;
            }

            leaf if-id {
              when "not(contains(/ncs:devices/lsa-utils:lsa/lsa-utils:dispatch-map/lsa-utils:device
                  [lsa-utils:name=current()/../../../../../../../ne-id]/lsa-utils:ned-id,
                  'cisco-ios-cli-'))
                  or
                  not(../../../../../connection/tagged-interface/dot1q-vlan-tagged/BDI)";
              tailf:info "Interface Id";
              description "Interface Id";
              type string {
                pattern '[0-9]+(/[0-9]+)*';
              }
              mandatory true;
            }

            leaf sub-if-id {
              when "not(contains(/ncs:devices/lsa-utils:lsa/lsa-utils:dispatch-map/lsa-utils:device
                  [lsa-utils:name=current()/../../../../../../../ne-id]/lsa-utils:ned-id,
                  'cisco-ios-cli-')) or ../if-type != 'Loopback'";
              tailf:info "Sub Interface Id";
              description "Sub Interface Id";
              type int32;
            }

            must "not(if-type) or (((if-type!='Loopback' and if-type!='Bundle-Ether') or " +
                " ((if-type='Loopback' or if-type='Bundle-Ether')
                and (string(number(if-id))!='NaN'))))" {
              error-message "Id must be a number";
            }
            must "not(if-type) or (((if-type!='Bundle-Ether') or (if-type='Bundle-Ether')
                and (string(number(if-id))>'0')
                and (string(number(if-id))<'65536')))" {
              error-message "if-id must be in the range 1-65535";
            }
            must "not(if-type) or (((if-type!='Loopback') or (if-type='Loopback')
                and (string(number(if-id))>='0')
                and (string(number(if-id))<='2147483647')))" {
              error-message "if-id must be in the range 0-2147483647";
            }
          }

          leaf mpls-deactivation {
            tailf:info "Set to true to disable BGP MPLS forwarding.";
            description "Set to true to disable BGP MPLS forwarding.";
            type boolean;
            default "false";
          }
          // NSO ADDITION END
          /*  Extension  */
          leaf-list neighbor {
            type inet:ip-address;
            description
              "IP address(es) of the BGP neighbor. An IPv4
               and IPv6 neighbors may be indicated if
               two sessions will be used for IPv4 and IPv6.";
            tailf:info
              "IP address(es) of the BGP neighbor. An IPv4
               and IPv6 neighbors may be indicated if
               two sessions will be used for IPv4 and IPv6.";
          }
          leaf multihop {
            type uint8;
            description
              "Describes the number of hops allowed between
               a given BGP neighbor and the PE router.";
            tailf:info
              "Describes the number of hops allowed between
               a given BGP neighbor and the PE router.";
          }
          // NSO-REMOVED START
          // uses security-params;
          // uses status-params;
          // leaf description {
          //   type string;
          //   description
          //     "Includes a description of the BGP session.
          //      Such description is meant to be used for
          //      diagnosis purposes. The semantic of the description
          //      is local to an implementation.";
          // }
          // NSO-REMOVED END
          /* End- Extension  */
          description
            "BGP-specific configuration.";
        }
        // NSO-REMOVED START
        // container isis {
        //   when "derived-from-or-self(../type, 'l3vpn-ntw:isis')" {
        //     description
        //       "Only applies when protocol is ISIS.";
        //   }
        //   if-feature "rtg-isis";
        //   leaf-list address-family {
        //     type l3vpn-svc:address-family;
        //     min-elements 1;
        //     description
        //       "If ISIS is used on this site, this node
        //        contains a configured value.  This node
        //        contains at least one address family
        //        to be activated.";
        //   }
        //   leaf area-address {
        //     type area-address;
        //     mandatory true;
        //     description
        //       "Area address.";
        //   }
        //   leaf level {
        //     type isis-level;
        //     description
        //       "level1, level2 or level1-2";
        //   }
        //   leaf metric {
        //     type uint16;
        //     default "1";
        //     description
        //       "Metric of the PE-CE link.  It is used
        //        in the routing state calculation and
        //        path selection.";
        //   }
        //   leaf process-id {
        //     type uint16;
        //     description
        //       "Process id of the ISIS CE-PE connection.";
        //   }
        //   leaf mode {
        //     type enumeration {
        //       enum active {
        //         description
        //           "Interface sends or receives ISIS protocol
        //            control packets.";
        //       }
        //       enum passive {
        //         description
        //           "Suppresses the sending of ISIS routing updates
        //            through the specified interface.";
        //       }
        //     }
        //     default "active";
        //     description
        //       "ISIS interface mode type.";
        //   }
        //   uses status-params;
        //   description
        //     "ISIS-specific configuration.";
        // }
        // container static {
        //   when "derived-from-or-self(../type, 'l3vpn-svc:static')" {
        //     description
        //       "Only applies when protocol is static.
        //        BGP activation requires the SP to know
        //        the address of the customer peer.  When
        //        BGP is enabled, the 'static-address'
        //        allocation type for the IP connection
        //        MUST be used.";
        //   }
        //   container cascaded-lan-prefixes {
        //     list ipv4-lan-prefixes {
        //       if-feature "l3vpn-svc:ipv4";
        //       key "lan next-hop";
        //       leaf lan {
        //         type inet:ipv4-prefix;
        //         description
        //           "LAN prefixes.";
        //       }
        //       leaf lan-tag {
        //         type string;
        //         description
        //           "Internal tag to be used in VPN policies.";
        //       }
        //       leaf next-hop {
        //         type inet:ipv4-address;
        //         description
        //           "Next-hop address to use on the customer side.";
        //       }
        //       description
        //         "List of LAN prefixes for the site.";
        //     }
        //     list ipv6-lan-prefixes {
        //       if-feature "l3vpn-svc:ipv6";
        //       key "lan next-hop";
        //       leaf lan {
        //         type inet:ipv6-prefix;
        //         description
        //           "LAN prefixes.";
        //       }
        //       leaf lan-tag {
        //         type string;
        //         description
        //           "Internal tag to be used in VPN policies.";
        //       }
        //       leaf next-hop {
        //         type inet:ipv6-address;
        //         description
        //           "Next-hop address to use on the customer side.";
        //       }
        //       description
        //         "List of LAN prefixes for the site.";
        //     }
        //     description
        //       "LAN prefixes from the customer.";
        //   }
        //   description
        //     "Configuration specific to static routing.";
        // }
        // container rip {
        //   when "derived-from-or-self(../type, 'l3vpn-svc:rip')" {
        //     description
        //       "Only applies when the protocol is RIP.  For IPv4,
        //        the model assumes that RIP version 2 is used.";
        //   }
        //   if-feature "l3vpn-svc:rtg-rip";
        //   leaf-list address-family {
        //     type l3vpn-svc:address-family;
        //     min-elements 1;
        //     description
        //       "If RIP is used on this site, this node
        //        contains a configured value.  This node
        //        contains at least one address family
        //        to be activated.";
        //   }
        //   description
        //     "Configuration specific to RIP routing.";
        // }
        // container vrrp {
        //   when "derived-from-or-self(../type, 'l3vpn-svc:vrrp')" {
        //     description
        //       "Only applies when protocol is VRRP.";
        //   }
        //   if-feature "l3vpn-svc:rtg-vrrp";
        //   leaf-list address-family {
        //     type l3vpn-svc:address-family;
        //     min-elements 1;
        //     description
        //       "If VRRP is used on this site, this node
        //        contains a configured value.  This node contains
        //        at least one address family to be activated.";
        //   }
        //   description
        //     "Configuration specific to VRRP routing.";
        // }
        // NSO-REMOVED END
        description
          "List of routing protocols used on
           the site.  This list can be augmented.";
        tailf:info "List of routing protocols used on
           the site.";
      }
      description
        "Defines routing protocols.";
      tailf:info
        "Defines routing protocols.";
    }
    description
      "Grouping for routing protocols.";
  }

  grouping site-attachment-ip-connection {
    container ip-connection {
      container ipv4 {
        if-feature "l3vpn-svc:ipv4";
        leaf address-allocation-type {
          type identityref {
            base l3vpn-svc:address-allocation-type;
          }
          must "not(derived-from-or-self(current(), 'l3vpn-svc:slaac')"
             + " or derived-from-or-self(current(), "
             + "'l3vpn-svc:provider-dhcp-slaac'))" {
            error-message "SLAAC is only applicable to IPv6";
          }
          description
            "Defines how addresses are allocated.
             If there is no value for the address
             allocation type, then IPv4 is not enabled.";
          tailf:info
            "Defines how addresses are allocated.
             If there is no value for the address
             allocation type, then IPv4 is not enabled.";
        }
        // NSO-REMOVED START
        // container provider-dhcp {
        //   when "derived-from-or-self(../address-allocation-type, "
        //      + "'l3vpn-svc:provider-dhcp')" {
        //     description
        //       "Only applies when addresses are allocated by DHCP.";
        //   }
        //   leaf provider-address {
        //     type inet:ipv4-address;
        //     description
        //       "Address of provider side.  If provider-address is not
        //        specified, then prefix length should not be specified
        //        either.  It also implies provider-dhcp allocation is
        //        not enabled.  If provider-address is specified, then
        //        the prefix length may or may not be specified.";
        //     tailf:info
        //       "Address of provider side.  If provider-address is not
        //        specified, then prefix length should not be specified
        //        either.  It also implies provider-dhcp allocation is
        //        not enabled.  If provider-address is specified, then
        //        the prefix length may or may not be specified.";
        //   }
        //   leaf prefix-length {
        //     type uint8 {
        //       range "0..32";
        //     }
        //     must '(../provider-address)' {
        //       error-message
        //         "If the prefix length is specified, provider-address
        //          must also be specified.";
        //       description
        //         "If the prefix length is specified, provider-address
        //          must also be specified.";
        //     }
        //     description
        //       "Subnet prefix length expressed in bits.
        //        If not specified, or specified as zero,
        //        this means the customer leaves the actual
        //        prefix length value to the provider.";
        //     tailf:info
        //       "Subnet prefix length expressed in bits.
        //        If not specified, or specified as zero,
        //        this means the customer leaves the actual
        //        prefix length value to the provider.";
        //   }
        //   choice address-assign {
        //     default "number";
        //     case number {
        //       leaf number-of-dynamic-address {
        //         type uint16;
        //         default "1";
        //         description
        //           "Describes the number of IP addresses
        //            the customer requires.";
        //       }
        //     }
        //     case explicit {
        //       container customer-addresses {
        //         list address-group {
        //           key "group-id";
        //           leaf group-id {
        //             type string;
        //             description
        //               "Group-id for the address range from
        //                start-address to end-address.";
        //           }
        //           leaf start-address {
        //             type inet:ipv4-address;
        //             description
        //               "First address.";
        //           }
        //           leaf end-address {
        //             type inet:ipv4-address;
        //             description
        //               "Last address.";
        //           }
        //           description
        //             "Describes IP addresses allocated by DHCP.
        //              When only start-address or only end-address
        //              is present, it represents a single address.
        //              When both start-address and end-address are
        //              specified, it implies a range inclusive of both
        //              addresses.  If no address is specified, it implies
        //              customer addresses group is not supported.";
        //         }
        //         description
        //           "Container for customer addresses is allocated by
        //            DHCP.";
        //       }
        //     }
        //     description
        //       "Choice for the way to assign addresses.";
        //   }
        //   description
        //     "DHCP allocated addresses related parameters.";
        // }
        // container dhcp-relay {
        //   when "derived-from-or-self(../address-allocation-type, "
        //      + "'l3vpn-svc:provider-dhcp-relay')" {
        //     description
        //       "Only applies when provider is required to implement
        //        DHCP relay function.";
        //   }
        //   leaf provider-address {
        //     type inet:ipv4-address;
        //     description
        //       "Address of provider side.  If provider-address is not
        //        specified, then prefix length should not be specified
        //        either.  It also implies provider-dhcp allocation is
        //        not enabled.  If provider-address is specified, then
        //        prefix length may or may not be specified.";
        //   }
        //   leaf prefix-length {
        //     type uint8 {
        //       range "0..32";
        //     }
        //     must '(../provider-address)' {
        //       error-message
        //         "If prefix length is specified, provider-address
        //          must also be specified.";
        //       description
        //         "If prefix length is specified, provider-address
        //          must also be specified.";
        //     }
        //     description
        //       "Subnet prefix length expressed in bits.  If not
        //        specified, or specified as zero, this means the
        //        customer leaves the actual prefix length value
        //        to the provider.";
        //   }
        //   container customer-dhcp-servers {
        //     leaf-list server-ip-address {
        //       type inet:ipv4-address;
        //       description
        //         "IP address of customer DHCP server.";
        //     }
        //     description
        //       "Container for list of customer DHCP servers.";
        //   }
        //   description
        //     "DHCP relay provided by operator.";
        // }
        // NSO-REMOVED END
        container static-addresses {
          presence "true";
          when "derived-from-or-self(../address-allocation-type, "
             + "'l3vpn-svc:static-address')" {
            description
              "Only applies when protocol allocation type is static.";
          }
          leaf primary-address {
            type leafref {
              path "../address/address-id";
            }
            description
              "Provider address of the connection.";
            tailf:info
              "Provider address of the connection.";
          }
          list address {
            key "address-id";
            leaf address-id {
              type string;
              description
                "A unique string identifier for provider-addresses";
              tailf:info
                "A unique string identifier for provider-addresses";
            }
            leaf provider-address {
              type inet:ipv4-address;
              description
                "IPv4 Address of the provider side.
                 When the protocol allocation type is static,
                 the provider address must be configured.";
              tailf:info
                "IPv4 Address of the provider side.
                 When the protocol allocation type is static,
                 the provider address must be configured.";
            }
            // NSO-REMOVED START
            // leaf customer-address {
            //   type inet:ipv4-address;
            //   description
            //     "IPv4 Address of customer side.";
            // }
            // NSO-REMOVED END
            leaf prefix-length {
              type uint8 {
                range "0..32";
              }
              description
                "Subnet prefix length expressed in bits. Range<0-32>.
                 It is applied to both provider-address
                 and customer-address.";
              tailf:info
                "Subnet prefix length expressed in bits. Range<0-32>.
                 It is applied to both provider-address
                 and customer-address.";
            }
            description
              "Describes IPv4 addresses used.";
          }
          description
            "Describes IPv4 addresses used.";
        }
        description
          "IPv4-specific parameters.";
      }
      container ipv6 {
        if-feature "l3vpn-svc:ipv6";
        leaf address-allocation-type {
          type identityref {
            base l3vpn-svc:address-allocation-type;
          }
          description
            "Defines how addresses are allocated.
             If there is no value for the address
             allocation type, then IPv6 is
             not enabled.";
        }
        // NSO-REMOVED START
        // container provider-dhcp {
        //   when "derived-from-or-self(../address-allocation-type, "
        //      + "'l3vpn-svc:provider-dhcp') "
        //      + "or derived-from-or-self(../address-allocation-type, "
        //      + "'l3vpn-svc:provider-dhcp-slaac')" {
        //     description
        //       "Only applies when addresses are allocated by DHCP.";
        //   }
        //   leaf provider-address {
        //     type inet:ipv6-address;
        //     description
        //       "Address of the provider side.  If provider-address
        //        is not specified, then prefix length should not be
        //        specified either.  It also implies provider-dhcp
        //        allocation is not enabled.  If provider-address is
        //        specified, then prefix length may or may
        //        not be specified.";
        //     tailf:info
        //       "Address of the provider side.  If provider-address
        //        is not specified, then prefix length should not be
        //        specified either.  It also implies provider-dhcp
        //        allocation is not enabled.  If provider-address is
        //        specified, then prefix length may or may
        //        not be specified.";
        //   }
        //   leaf prefix-length {
        //     type uint8 {
        //       range "0..128";
        //     }
        //     must '(../provider-address)' {
        //       error-message
        //         "If prefix length is specified, provider-address
        //          must also be specified.";
        //       description
        //         "If prefix length is specified, provider-address
        //          must also be specified.";
        //     }
        //     description
        //       "Subnet prefix length expressed in bits.  If not
        //        specified, or specified as zero, this means the
        //        customer leaves the actual prefix length value
        //        to the provider.";
        //     tailf:info
        //       "Subnet prefix length expressed in bits.  If not
        //        specified, or specified as zero, this means the
        //        customer leaves the actual prefix length value
        //        to the provider.";
        //   }
        //   choice address-assign {
        //     default "number";
        //     case number {
        //       leaf number-of-dynamic-address {
        //         type uint16;
        //         default "1";
        //         description
        //           "Describes the number of IP addresses the customer
        //            requires.";
        //       }
        //     }
        //     case explicit {
        //       container customer-addresses {
        //         list address-group {
        //           key "group-id";
        //           leaf group-id {
        //             type string;
        //             description
        //               "Group-id for the address range from
        //                start-address to end-address.";
        //           }
        //           leaf start-address {
        //             type inet:ipv6-address;
        //             description
        //               "First address.";
        //           }
        //           leaf end-address {
        //             type inet:ipv6-address;
        //             description
        //               "Last address.";
        //           }
        //           description
        //             "Describes IP addresses allocated by DHCP.
        //              When only start-address or only end-address
        //              is present, it represents a single address.
        //              When both start-addressand end-address are
        //              specified, it implies a range
        //              inclusive of both addresses.
        //              If no address is specified, it implies
        //              customer addresses group is
        //              not supported.";
        //         }
        //         description
        //           "Container for customer addresses allocated
        //            by DHCP.";
        //       }
        //     }
        //     description
        //       "Choice for the way to assign addresses.";
        //   }
        //   description
        //     "DHCP allocated addresses related parameters.";
        // }
        // container dhcp-relay {
        //   when "derived-from-or-self(../address-allocation-type, "
        //      + "'l3vpn-svc:provider-dhcp-relay')" {
        //     description
        //       "Only applies when the provider is required
        //        to implement DHCP relay function.";
        //   }
        //   leaf provider-address {
        //     type inet:ipv6-address;
        //     description
        //       "Address of the provider side.  If provider-address
        //        is not specified, then prefix length should not be
        //        specified either.  It also implies provider-dhcp
        //        allocation is not enabled.  If provider address
        //        is specified, then prefix length may or may
        //        not be specified.";
        //   }
        //   leaf prefix-length {
        //     type uint8 {
        //       range "0..128";
        //     }
        //     must '(../provider-address)' {
        //       error-message
        //         "If prefix length is specified, provider-address
        //          must also be specified.";
        //       description
        //         "If prefix length is specified, provider-address
        //          must also be specified.";
        //     }
        //     description
        //       "Subnet prefix length expressed in bits.  If not
        //        specified, or specified as zero, this means the
        //        customer leaves the actual prefix length value
        //        to the provider.";
        //   }
        //   container customer-dhcp-servers {
        //     leaf-list server-ip-address {
        //       type inet:ipv6-address;
        //       description
        //         "This node contains the IP address of
        //          the customer DHCP server.  If the DHCP relay
        //          function is implemented by the
        //          provider, this node contains the
        //          configured value.";
        //     }
        //     description
        //       "Container for list of customer DHCP servers.";
        //   }
        //   description
        //     "DHCP relay provided by operator.";
        // }
        // NSO-REMOVED END
        container static-addresses {
          when "derived-from-or-self(../address-allocation-type, "
             + "'l3vpn-svc:static-address')" {
            description
              "Only applies when protocol allocation type is static.";
          }
          leaf primary-address {
            type leafref {
              path "../address/address-id";
            }
            tailf:info "Provider address of the connection";
            description "Provider address of the connection";
          }
          list address {
            key "address-id";
            leaf address-id {
              type string;
              tailf:info "A unique string identifier for provider-addresses";
              description "A unique string identifier for provider-addresses";
            }
            leaf provider-address {
              type inet:ipv6-address;
              tailf:info
                "IPv6 Address of the provider side.  When the protocol
                 allocation type is static, the provider address
                 must be configured.";
              description
                "IPv6 Address of the provider side.  When the protocol
                 allocation type is static, the provider address
                 must be configured.";
            }
            // NSO-REMOVED START
            // leaf customer-address {
            //   type inet:ipv6-address;
            //   description
            //     "The IPv6 Address of the customer side.";
            // }
            // NSO-REMOVED END
            leaf prefix-length {
              type uint8 {
                range "0..128";
              }
              tailf:info "Subnet prefix length expressed in bits. Range<0-128>.
                 It is applied to both provider-address and
                 customer-address.";
              description "Subnet prefix length expressed in bits. Range<0-128>.
                 It is applied to both provider-address and
                 customer-address.";
            }
            description
              "Describes IPv6 addresses used.";
          }
          description
            "IPv6-specific parameters.";
        }
        description
          "IPv6-specific parameters.";
      }
      // NSO-REMOVED START
      // container oam {
      //   container bfd {
      //     if-feature "l3vpn-svc:bfd";
      //     leaf enabled {
      //       type boolean;
      //       default "false";
      //       description
      //         "If true, BFD activation is required.";
      //     }
      //     choice holdtime {
      //       default "fixed";
      //       case fixed {
      //         leaf fixed-value {
      //           type uint32;
      //           units "msec";
      //           description
      //           "Expected BFD holdtime expressed in msec. The customer
      //            may impose some fixed values for the holdtime period
      //            if the provider allows the customer use this function.
      //            If the provider doesn't allow the customer to use this
      //            function, the fixed-value will not be set.";
      //         }
      //       }
      //       case profile {
      //         leaf profile-name {
      //           type leafref {
      //             path "/l3vpn-ntw/vpn-profiles/"
      //                + "valid-provider-identifiers/"
      //                + "bfd-profile-identifier/id";
      //           }
      //           description
      //           "Well-known SP profile name. The provider can propose
      //            some profiles to the customer, depending on the
      //            service level the customer wants to achieve.
      //            Profile names must be communicated to the customer.";
      //         }
      //         description
      //           "Well-known SP profile.";
      //       }
      //       description
      //         "Choice for holdtime flavor.";
      //     }
      //     description
      //       "Container for BFD.";
      //   }
      //   description
      //     "Defines the Operations, Administration, and Maintenance (OAM)
      //      mechanisms used on the connection.  BFD is set as a fault
      //      detection mechanism, but the 'oam' container can easily
      //      be augmented by other mechanisms";
      // }
      // NSO-REMOVED END
      description
        "Defines connection parameters.";
      tailf:info
        "Defines connection parameters.";
    }
    description
      "This grouping defines IP connection parameters.";
  }

  // NSO-REMOVED START
  // grouping site-service-multicast {
  //   container multicast {
  //     if-feature "l3vpn-svc:multicast";
  //     leaf site-type {
  //       type enumeration {
  //         enum receiver-only {
  //           description
  //             "The site only has receivers.";
  //         }
  //         enum source-only {
  //           description
  //             "The site only has sources.";
  //         }
  //         enum source-receiver {
  //           description
  //             "The site has both sources and receivers.";
  //         }
  //       }
  //       default "source-receiver";
  //       description
  //         "Type of multicast site.";
  //     }
  //     container address-family {
  //       leaf ipv4 {
  //         if-feature "l3vpn-svc:ipv4";
  //         type boolean;
  //         default "false";
  //         description
  //           "Enables IPv4 multicast.";
  //       }
  //       leaf ipv6 {
  //         if-feature "l3vpn-svc:ipv6";
  //         type boolean;
  //         default "false";
  //         description
  //           "Enables IPv6 multicast.";
  //       }
  //       description
  //         "Defines protocol to carry multicast.";
  //     }
  //     leaf protocol-type {
  //       type enumeration {
  //         enum host {
  //           description
  //             "Hosts are directly connected to the provider network.
  //              Host protocols such as IGMP or MLD are required.";
  //         }
  //         enum router {
  //           description
  //             "Hosts are behind a customer router.
  //              PIM will be implemented.";
  //         }
  //         enum both {
  //           description
  //             "Some hosts are behind a customer router, and
  //              some others are directly connected to the
  //              provider network.  Both host and routing protocols
  //              must be used.  Typically, IGMP and PIM will be
  //              implemented.";
  //         }
  //       }
  //       default "both";
  //       description
  //         "Multicast protocol type to be used with the customer site.";
  //     }
  //     leaf remote-source {
  //       type boolean;
  //       default "false";
  //       description
  //         "When true, there is no PIM adjacency on the interface.";
  //     }
  //     description
  //       "Multicast parameters for the site.";
  //   }
  //   description
  //     "Multicast parameters for the site.";
  // }
  //
  // grouping site-maximum-routes {
  //   container maximum-routes {
  //     list address-family {
  //       key "af";
  //       leaf af {
  //         type l3vpn-svc:address-family;
  //         description
  //           "Address family.";
  //       }
  //       leaf maximum-routes {
  //         type uint32;
  //         description
  //           "Maximum prefixes the VRF can accept
  //            for this address family.";
  //       }
  //       description
  //         "List of address families.";
  //     }
  //     description
  //       "Defines 'maximum-routes' for the VRF.";
  //   }
  //   description
  //     "Defines 'maximum-routes' for the site.";
  // }
  //
  // grouping site-security {
  //   container security {
  //
  //     uses site-security-authentication;
  //     uses site-security-encryption;
  //     description
  //       "Site-specific security parameters.";
  //   }
  //   description
  //     "Grouping for security parameters.";
  // }
  //
  // grouping network-access-service {
  //   container service {
  //     uses site-service-basic;
  //     // Extension
  //     // uses svc-bandwidth-params;
  //     // EoExt
  //     uses site-service-qos-profile;
  //     uses site-service-mpls;
  //     uses site-service-multicast;
  //     description
  //       "Service parameters on the attachment.";
  //   }
  //   description
  //     "Grouping for service parameters.";
  // }
  //
  // grouping vpn-extranet {
  //   container extranet-vpns {
  //     if-feature "l3vpn-svc:extranet-vpn";
  //     list extranet-vpn {
  //       key "vpn-id";
  //       leaf vpn-id {
  //         type l3vpn-svc:svc-id;
  //         description
  //           "Identifies the target VPN the local VPN want to access.";
  //       }
  //       leaf local-sites-role {
  //         type identityref {
  //           base l3vpn-svc:site-role;
  //         }
  //         default "l3vpn-svc:any-to-any-role";
  //         description
  //         "This describes the role of the
  //          local sites in the target VPN topology.
  //          In the any-to-any VPN service topology,
  //          the local sites must have the same role, which
  //          will be 'any-to-any-role'.  In the Hub-and-Spoke
  //          VPN service topology or the Hub-and-Spoke
  //          disjoint VPN service topology,
  //          the local sites must have a Hub role or a Spoke role.";
  //       }
  //       description
  //         "List of extranet VPNs or target VPNs the local VPN is
  //          attached to.";
  //     }
  //     description
  //       "Container for extranet VPN configuration.";
  //   }
  //   description
  //     "Grouping for extranet VPN configuration.
  //      This provides an easy way to interconnect
  //      all sites from two VPNs.";
  // }
  // NSO-REMOVED END

  grouping vpn-profile-cfg {
    container valid-provider-identifiers {
      // NSO-REMOVED START
      // list cloud-identifier {
      //   if-feature "l3vpn-svc:cloud-access";
      //   key "id";
      //   leaf id {
      //     type string;
      //     description
      //       "Identification of cloud service.
      //        Local administration meaning.";
      //   }
      //   description
      //     "List for Cloud Identifiers.";
      // }
      // list encryption-profile-identifier {
      //   key "id";
      //   leaf id {
      //     type string;
      //     description
      //       "Identification of the SP encryption profile
      //        to be used.  Local administration meaning.";
      //   }
      //   description
      //     "List for encryption profile identifiers.";
      // }
      // list qos-profile-identifier {
      //   key "id";
      //   leaf id {
      //     type string;
      //     description
      //       "Identification of the QoS Profile to be used.
      //        Local administration meaning.";
      //   }
      //   description
      //     "List for QoS Profile Identifiers.";
      // }
      // list bfd-profile-identifier {
      //   key "id";
      //   leaf id {
      //     type string;
      //     description
      //       "Identification of the SP BFD Profile to be used.
      //        Local administration meaning.";
      //   }
      //   description
      //     "List for BFD Profile identifiers.";
      // }
      // NSO-REMOVED END
      list routing-profile-identifier {
        key "id";
        leaf id {
          type string;
          description
            "Identification of the routing Profile to be used
             by the routing-protocols within sites, vpn-
             network-accesses or vpn-nodes for refering
       vrf-import/export policies.
             This identifier has a local meaning.";
          tailf:info "Identification of the routing Profile to be used
             by the routing-protocols within sites, vpn-
             network-accesses or vpn-nodes for refering
       vrf-import/export policies.
             This identifier has a local meaning";
        }
        description
          "List for Routing Profile Identifiers.";
      }
      nacm:default-deny-write;
      description
        "Container for Valid Provider Identifies.";
    }
    description
      "Grouping for VPN Profile configuration.";
  }

  grouping vpn-svc-cfg {
    leaf vpn-id {
      type l3vpn-svc:svc-id;
      description
        "VPN identifier. This identifier has a local meaning.";
      tailf:info
        "VPN identifier. This identifier has a local meaning.";
    }

    // NSO-REMOVED START
    // leaf l3sm-vpn-id {
    //   type l3vpn-svc:svc-id;
    //   description
    //     "Pointer to the L3SM service.";
    // }
    // leaf customer-name {
    //   type string;
    //   description
    //   "Name of the customer that actually uses the VPN service.
    //    In the case that any intermediary (e.g., Tier-2 provider
    //    or partner) sells the VPN service to their end user
    //    on behalf of the original service provider (e.g., Tier-1
    //    provider), the original service provider may require the
    //    customer name to provide smooth activation/commissioning
    //    and operation for the service.";
    // }
    // leaf vpn-service-topology {
    //   type identityref {
    //     base vpn-topology;
    //   }
    //   default "any-to-any";
    //   description
    //     "VPN service topology.";
    // }
    // leaf description {
    //   type string;
    //   description
    //     "Textual description of a VPN service.";
    //   tailf:info
    //     "Textual description of a VPN service.";
    // }
    // NSO-REMOVED END
    uses ie-profiles-params;
    uses vpn-nodes-params;
    // NSO-REMOVED START
    // uses svc-transport-encapsulation;
    // uses vpn-service-multicast;
    // uses vpn-service-mpls;
    // uses vpn-extranet;
    // NSO-REMOVED END
    description
      "Grouping for VPN service configuration.";
  }

  grouping site-network-access-top-level-cfg {
    // NSO-REMOVED START
    // uses status-params;
    // leaf vpn-network-access-type {
    //   type identityref {
    //     base l3vpn-svc:site-network-access-type;
    //   }
    //   default "l3vpn-svc:point-to-point";
    //   description
    //     "Describes the type of connection, e.g.,
    //      point-to-point or multipoint.";
    // }
    // NSO-REMOVED END
    uses ethernet-params;
    uses site-attachment-ip-connection;
    uses site-routing;

    // NSO-REMOVED START
    // uses site-security;
    // uses network-access-service;
    // NSO-REMOVED END

    description
      "Grouping for site network access top-level configuration.";
  }

  // /* Bearers in a site */

  // NSO-REMOVED START
  // grouping site-bearer-params {
  //   container site-bearers {
  //     list bearer {
  //       key "bearer-id";
  //       leaf bearer-id {
  //         type string;
  //         description
  //           "";
  //       }
  //       leaf BearerType {
  //         type identityref {
  //           base bearer-inf-type;
  //         }
  //         description
  //           "Request for an Bearer access type.
  //            Choose between port or lag connection type.";
  //       }
  //       leaf ne-id {
  //         type string;
  //         description
  //           "NE-id reference.";
  //       }
  //       leaf port-id {
  //         type string;
  //         description
  //           "Reference to the Port-id.
  //            The semantic of the Port-Id depends on the vendor's
  //            semantic. i.e ge-X/Y/Z , xe-X/Y/Z , et-X/Y/Z,AeXXX.YYY,
  //            aeXXX,GigabitEthernetX/Y/Z";
  //       }
  //       leaf lag-id {
  //         type string;
  //         description
  //           "lag-id in format id.";
  //       }
  //       description
  //         "Parameters used to identify each bearer";
  //     }
  //     description
  //       "Grouping to reuse the site bearer assigment";
  //   }
  //   description
  //     "Grouping to reuse the site bearer assigment";
  // }
  //
  // grouping svc-bandwidth-params {
  //   container svc-bandwidth {
  //     if-feature "input-bw";
  //     list bandwidth {
  //       key "direction type";
  //       leaf direction {
  //         type identityref {
  //           base bw-direction;
  //         }
  //         description
  //           "Indicates the bandwidth direction.  It can be
  //            the bandwidth download direction from the SP to
  //            the site or the bandwidth upload direction from
  //            the site to the SP.";
  //       }
  //       leaf type {
  //         type identityref {
  //           base bw-type;
  //         }
  //         description
  //           "Bandwidth type.  By default, the bandwidth type
  //            is set to 'bw-per-cos'.";
  //       }
  //       leaf cos-id {
  //         when "derived-from-or-self(../type, "
  //            + "'l3vpn-ntw:bw-per-cos')" {
  //           description
  //             "Relevant when the bandwidth type is set to
  //              'bw-per-cos'.";
  //         }
  //         type uint8;
  //         description
  //           "Identifier of the CoS, indicated by DSCP or a
  //            CE-VLAN CoS (802.1p) value in the service frame.
  //            If the bandwidth type is set to 'bw-per-cos',
  //            the CoS ID MUST also be specified.";
  //       }
  //       leaf vpn-id {
  //         when "derived-from-or-self(../type, "
  //            + "'l3vpn-ntw:bw-per-svc')" {
  //           description
  //             "Relevant when the bandwidth type is
  //              set as bandwidth per VPN service.";
  //         }
  //         type l3vpn-svc:svc-id;
  //         description
  //           "Identifies the target VPN.  If the bandwidth
  //            type is set as bandwidth per VPN service, the
  //            vpn-id MUST be specified.";
  //       }
  //       leaf cir {
  //         type uint64;
  //         units "bps";
  //         mandatory true;
  //         description
  //           "Committed Information Rate.  The maximum number
  //            of bits that a port can receive or send over
  //            an interface in one second.";
  //       }
  //       leaf cbs {
  //         type uint64;
  //         units "bps";
  //         mandatory true;
  //         description
  //           "Committed Burst Size (CBS).  Controls the bursty
  //            nature of the traffic.  Traffic that does not
  //            use the configured Committed Information Rate
  //            (CIR) accumulates credits until the credits
  //            reach the configured CBS.";
  //       }
  //       leaf eir {
  //         type uint64;
  //         units "bps";
  //         description
  //           "Excess Information Rate (EIR), i.e., excess frame
  //            delivery allowed that is not subject to an SLA.
  //            The traffic rate can be limited by the EIR.";
  //       }
  //       leaf ebs {
  //         type uint64;
  //         units "bps";
  //         description
  //           "Excess Burst Size (EBS).  The bandwidth available
  //            for burst traffic from the EBS is subject to the
  //            amount of bandwidth that is accumulated during
  //            periods when traffic allocated by the EIR
  //            policy is not used.";
  //       }
  //       leaf pir {
  //         type uint64;
  //         units "bps";
  //         description
  //           "Peak Information Rate, i.e., maximum frame
  //            delivery allowed.  It is equal to or less
  //            than the sum of the CIR and the EIR.";
  //       }
  //       leaf pbs {
  //         type uint64;
  //         units "bps";
  //         description
  //           "Peak Burst Size.  It is measured in bytes per
  //            second.";
  //       }
  //       description
  //         "List of bandwidth values (e.g., per CoS,
  //          per vpn-id).";
  //     }
  //     description
  //       "From the customer site's perspective, the service
  //        input/output bandwidth of the connection or
  //        download/upload bandwidth from the SP/site
  //        to the site/SP.";
  //   }
  //   description
  //     " ";
  // }
  //
  // grouping status-params {
  //   container status {
  //     leaf admin-enabled {
  //       type boolean;
  //       description
  //         "Administrative Status UP/DOWN";
  //     }
  //     leaf oper-status {
  //       type operational-type;
  //       config false;
  //       description
  //         "Operations status";
  //     }
  //     description
  //       "Container for status parameters.";
  //   }
  //   description
  //     "Grouping used to join operational and administrative status
  //      is re used in the Site Network Acess and in the VPN-Node";
  // }
  // NSO-REMOVED END

  /* Parameters related to vpn-nodes (VRF config.) */

  grouping vpn-nodes-params {
    container vpn-nodes {
      description
        "Container for VPN nodes.";
      tailf:info
        "Container for VPN nodes.";
      list vpn-node {
        key "ne-id";
        // NSO ADDITION START
        uses ct-hook:template-hook;
        tailf:action error-recovery {
          tailf:actionpoint ietf-l3vpn-nm-vpn-node-error-recovery;
          tailf:info "Action to recover this device during create/update from a transient failures
                      like device connection issues once the device is reachable again.
                      For create/update failures, this action issues a sync on the device
                      & redeploys the service with reconcile option.";
          description "Action to recover this device during create/update from a transient
                      failures like device connection issues once the device is reachable again.
                      For create/update failures, this action issues a sync on the device
                      & redeploys the service with reconcile option.";
          input {
            leaf vpn-network-access-id {
              tailf:info "Recover this vpn-node associated with vpn-network-access-id" +
                         "under given service.";
              description "Recover this vpn-node associated with vpn-network-access-id" +
                          "under given service.";
              type string;
              mandatory true;
            }
            leaf sync-direction {
              tailf:info "sync device with sync-from or sync-to";
              description "sync device with sync-from or sync-to";
              type enumeration {
                enum sync-from;
                enum sync-to;
              }
              mandatory true;
            }
          }
          output {
            leaf success {
              type boolean;
              mandatory true;
            }
            leaf detail {
              type string;
            }
          }
          tailf:confirm-text "########################\n" +
            "#        Warning       #\n" +
            "########################\n" +
            "You are about to recover a T-SDN service.\n" +
            "This will issue a sync on the device.\n" +
            "Are you sure you want to proceed?" {
              tailf:confirm-default false;
          }
        }
        // NSO ADDITION END
        // NSO-REMOVED START
        // leaf vpn-node-id {
        //   type union {
        //     type l3vpn-svc:svc-id;
        //     type uint32;
        //   }
        //   description
        //     "Type STRING or NUMBER Serivice-Id";
        // }
        // NSO-REMOVED END
        leaf local-autonomous-system {
          type inet:as-number;
          description
            "Provider AS number in case the customer
             requests BGP routing.";
          tailf:info
            "Provider AS number in case the customer
             requests BGP routing.";
        }
        // NSO-REMOVED START
        // leaf description {
        //   type string;
        //   description
        //     "Textual description of the VPN node.";
        //   tailf:info
        //     "Textual description of the VPN node.";
        // }
        // NSO-REMOVED END
        leaf ne-id {
          type string;
          description
            "Unique identifier of the network element
             where the vpn-node is deployed.";
          tailf:info
            "Unique identifier of the network element
             where the vpn-node is deployed.";
        }
        // NSO-REMOVED START
        // leaf router-id {
        //   type inet:ip-address;
        //   description
        //     "router-id information can be ipv4/6 addresses";
        // }
        // leaf address-family {
        //   type l3vpn-svc:address-family;
        //   description
        //     "Address family used for router-id information.";
        // }
        // leaf node-role {
        //   type identityref {
        //     base l3vpn-svc:site-role;
        //   }
        //   default "l3vpn-svc:any-to-any-role";
        //   description
        //     "Role of the vpn-node in the IP VPN.";
        // }
        // NSO-REMOVED END
        uses rt-rd;
        uses net-acc;

        // NSO-REMOVED START
        // uses status-params;
        // uses site-maximum-routes;
        // uses vpn-service-multicast;
        // NSO-REMOVED END

        leaf node-ie-profile {
          type leafref {
            path "../../../ie-profiles/ie-profile/ie-profile-id";
          }
          description
            "node Import/Export profile.";
          tailf:info
            "node Import/Export profile.";
        }
        description
          "List for VPN nodes.";
        tailf:info
          "List for VPN nodes.";
      }
    }
    description
      "Grouping to define VRF-specific configuration.";
  }

  /* Parameters related to import and export profiles (RTs RDs.) */

  grouping ie-profiles-params {
    container ie-profiles {
      list ie-profile {
        key "ie-profile-id";
        leaf ie-profile-id {
          type string;
          description
            "IE profile id.";
          tailf:info
            "IE profile id.";
        }
        uses rt-rd;
        description
          "List for Imort/Export profile.";
        tailf:info
          "List for Imort/Export profile.";
      }
      description
        "Container for Import/Export profiles.";
      tailf:info
        "Container for Import/Export profiles.";
    }
    description
      "Grouping to specify rules for route import and export";
  }

  // NSO-REMOVED START
  // grouping pseudowire-params {
  //   container pseudowire {
  //     /*leaf far-end {*/
  //     /*  description "IP of the remote peer of the pseudowire.";*/
  //     /*  type inet:ip-address;*/
  //     /*}*/
  //     leaf vcid {
  //       type uint32;
  //       description
  //         "PW or VC identifier.";
  //     }
  //     leaf far-end {
  //       type union {
  //         type uint32;
  //         type inet:ipv4-address;
  //       }
  //       description
  //         "SDP/Far End/LDP Neighbour reference.";
  //     }
  //     description
  //       "Pseudowire termination parameters";
  //   }
  //   container vpls {
  //     leaf vcid {
  //       type union {
  //         type uint32;
  //         type string;
  //       }
  //       description
  //         "VCID identifier,IRB/RVPPLs interface
  //          supported using string
  //          format.";
  //     }
  //     leaf far-end {
  //       type union {
  //         type uint32;
  //         type inet:ipv4-address;
  //       }
  //       description
  //         "SDP/Far End/LDP Neighbour reference.";
  //     }
  //     description
  //       "Pseudowire termination parameters";
  //   }
  //   description
  //     "Grouping pseudowire termination parameters";
  // }
  //
  // grouping security-params {
  //   container security {
  //     leaf auth-key {
  //       type string;
  //       description
  //         "MD5 authentication password for the connection towards the
  //          customer edge.";
  //     }
  //     description
  //       "Container for aggregating any security parameter for routing
  //        sessions between a PE and a CE.";
  //   }
  //   description
  //     "Grouping to define security parameters";
  // }
  // NSO-REMOVED END

  grouping ethernet-params {
    container connection {
      leaf encapsulation-type {
        type identityref {
          base encapsulation-type;
        }
        default "untagged-int";
        description
          "Encapsulation type.  By default, the
           encapsulation type is set to 'untagged'.";
        tailf:info
          "Encapsulation type.  By default, the
           encapsulation type is set to 'untagged'.";
      }
      // NSO-REMOVED START
      // container logical-interface {
      //   leaf peer-reference {
      //     type uint32;
      //     description
      //       "Specify the associated logical peer
      // interface";
      //   }
      //   description
      //     "Reference of a logical interface type.";
      // }
      // NSO-REMOVED END
      container tagged-interface {
        presence "true";
        when "../encapsulation-type='l3vpn-ntw:tagged-int'";
        leaf type {
          type identityref {
            base tagged-inf-type;
          }
          default "priority-tagged";
          description
            "Tagged interface type.  By default,
             the type of the tagged interface is
             'priority-tagged'.";
          tailf:info
            "Tagged interface type.  By default,
             the type of the tagged interface is
             'priority-tagged'.";
        }
        container dot1q-vlan-tagged {
          presence "true";
          when "derived-from-or-self(../type, "
             + "'l3vpn-ntw:dot1q')" {
            description
              "Only applies when the type of the tagged
               interface is 'dot1q'.";
          }
          if-feature "dot1q";
          // NSO-REMOVED START
          // leaf tag-type {
          //   type identityref {
          //     base tag-type;
          //   }
          //   default "c-vlan";
          //   description
          //     "Tag type.  By default, the tag type is
          //      'c-vlan'.";
          // }
          // NSO-REMOVED END
          leaf cvlan-id {
            when "not(contains(../../../../port-id, 'Loopback')) and not(contains(../../../../port-id, 'BVI'))";
            type uint16;
            // NSO MODIFICATION START
            tailf:info "<1-4094> - VLAN identifier";
            description "<1-4094> - VLAN identifier";
            // NSO MODIFICATION END
          }
          // NSO ADDITION START
          leaf BDI {
            tailf:info
              "BDI must be unique for each sub-interface on the device.
              <1-4095>;;BDI interface number";
            description
              "BDI must be unique for each sub-interface on the device.
              <1-4095>;;BDI interface number";
            when "../cvlan-id and contains(/ncs:devices/lsa-utils:lsa/lsa-utils:dispatch-map/lsa-utils:device
              [lsa-utils:name=current()/../../../../../../ne-id]/lsa-utils:ned-id,
              'cisco-ios-cli-')";
            type uint16 {
              range "1..4095";
            }
          }
          // NSO ADDITION END
          description
            "Tagged interface.";
          tailf:info
            "Tagged interface.";
        }

        // NSO-REMOVED START
        // container priority-tagged {
        //   when "derived-from-or-self(../type, "
        //      + "'l3vpn-ntw:priority-tagged')" {
        //     description
        //       "Only applies when the type of the tagged
        //        interface is 'priority-tagged'.";
        //   }
        //   leaf tag-type {
        //     type identityref {
        //       base tag-type;
        //     }
        //     default "c-vlan";
        //     description
        //       "Tag type.  By default, the tag type is
        //        'c-vlan'.";
        //   }
        //   description
        //     "Priority tagged.";
        // }
        // container qinq {
        //   when "derived-from-or-self(../type, "
        //      + "'l3vpn-ntw:qinq')" {
        //     description
        //       "Only applies when the type of the tagged
        //        interface is 'qinq'.";
        //   }
        //   if-feature "qinq";
        //   leaf tag-type {
        //     type identityref {
        //       base tag-type;
        //     }
        //     default "c-s-vlan";
        //     description
        //       "Tag type.  By default, the tag type is
        //        'c-s-vlan'.";
        //   }
        //   leaf svlan-id {
        //     type uint16;
        //     mandatory true;
        //     description
        //       "SVLAN identifier.";
        //   }
        //   leaf cvlan-id {
        //     type uint16;
        //     mandatory true;
        //     description
        //       "CVLAN identifier.";
        //   }
        //   description
        //     "QinQ.";
        // }
        // container qinany {
        //   when "derived-from-or-self(../type, "
        //      + "'l3vpn-ntw:qinany')" {
        //     description
        //       "Only applies when the type of the tagged
        //        interface is 'qinany'.";
        //   }
        //   if-feature "qinany";
        //   leaf tag-type {
        //     type identityref {
        //       base tag-type;
        //     }
        //     default "s-vlan";
        //     description
        //       "Tag type.  By default, the tag type is
        //        's-vlan'.";
        //   }
        //   leaf svlan-id {
        //     type uint16;
        //     mandatory true;
        //     description
        //       "Service VLAN ID.";
        //   }
        //   description
        //     "Container for QinAny.";
        // }
        // container vxlan {
        //   when "derived-from-or-self(../type, "
        //      + "'l3vpn-ntw:vxlan')" {
        //     description
        //       "Only applies when the type of the tagged
        //        interface is 'vxlan'.";
        //   }
        //   if-feature "vxlan";
        //   leaf vni-id {
        //     type uint32;
        //     mandatory true;
        //     description
        //       "VXLAN Network Identifier (VNI).";
        //   }
        //   leaf peer-mode {
        //     type identityref {
        //       base vxlan-peer-mode;
        //     }
        //     default "static-mode";
        //     description
        //       "Specifies the VXLAN access mode.  By default,
        //        the peer mode is set to 'static-mode'.";
        //   }
        //   list peer-list {
        //     key "peer-ip";
        //     leaf peer-ip {
        //       type inet:ip-address;
        //       description
        //         "Peer IP.";
        //     }
        //     description
        //       "List of peer IP addresses.";
        //   }
        //   description
        //     "QinQ.";
        // }
        // NSO-REMOVED END
        description
          "Container for tagged interfaces.";
      }
      // NSO-REMOVED START
      // container bearer {
      //   leaf bearer-reference {
      //     if-feature "l3vpn-svc:bearer-reference";
      //     type string;
      //     description
      //       "This is an internal reference for the SP.";
      //   }
      //   uses pseudowire-params;
      //   description
      //     "Defines physical properties of a site attachment.";
      // }
      // NSO-REMOVED END
      description
        "Encapsulation types";
      tailf:info
        "Encapsulation types";
    }
    description
      "Grouping to define encapsulation types";
  }

  grouping rt-rd {
    // COMPILE ERROR: NSO does not support YANG 1.1 type union with empty leaves
    // leaf rd {
    //   type union {
    //     type rt-types:route-distinguisher;
    //     type empty;
    // }
    //   description
    //    "Route distinguisher value. If this leaf has not been
    //     configured, the server will auto-assign a route
    //     distinguisher value and use that value operationally.
    //     This calculated value is available in the operational
    //     state. Use the empty type to indicate rd has no value
    //     and is not to be aouto-assigned";
    // }

    // NSO MODIFICATION START
    leaf rd {
      type rt-types:route-distinguisher;
      description "Route distinguisher value. If this leaf has not been
                   configured, the server will auto-assign a route
                   distinguisher value for XR devices. Example- 0:65100:87400024.
                   Please refer to IETF yang model for route distinguisher";
      tailf:info "Route distinguisher value. If this leaf has not been
                   configured, the server will auto-assign a route
                   distinguisher value for XR devices. Example- 0:65100:87400024.
                   Please refer to IETF yang model for route distinguisher";
    }
    // NSO MODIFICATION END

    container vpn-targets {
      description
        "Set of route-targets to match for import and export routes
         to/from VRF";
      tailf:info
        "Set of route-targets to match for import and export routes
         to/from VRF";
      //uses rt-types:vpn-route-targets;
      uses vpn-route-targets;
    }
    description
      "Grouping for RT and RD.";
  }

  grouping vpn-route-targets {
    description
      "A grouping that specifies Route Target import-export rules
       used in a BGP-enabled VPN.";
    list vpn-target {
      key "id";
      leaf id {
        type int8;
        description
          "Identifies each VPN Target. Range<-128..127>";
        tailf:info
          "Identifies each VPN Target. Range<-128..127>";
      }
      list route-targets {
        key "route-target";
        leaf route-target {
          type rt-types:route-target;
          description
            "Route Target value. Example- 0:65100:87400024.
            Refer to IETF route-target model";
          tailf:info
            "Route Target value. Example- 0:65100:87400024.
            Refer to IETF route-target model";
        }
        description
          "List of Route Targets.";
        tailf:info
          "List of Route Targets.";
      }
      leaf route-target-type {
        type rt-types:route-target-type;
        mandatory true;
        description
          "Import/export type of the Route Target.";
        tailf:info
          "Import/export type of the Route Target.";
      }
      description
        "l3vpn route targets. AND/OR Operations are available
         based on the RTs assigment";
      tailf:info
        "l3vpn route targets. AND/OR Operations are available
         based on the RTs assigment";
    }
    reference
      "RFC4364: BGP/MPLS IP Virtual Private Networks (VPNs)
       RFC4664: Framework for Layer 2 Virtual Private Networks
       (L2VPNs)";
    container vpn-policies {
      description
        "";
      tailf:info "Container for vpn-policies";
      leaf import-policy {
        type leafref {
          path "/l3vpn-ntw/vpn-profiles/valid-provider-identifiers/"
             + "routing-profile-identifier/id";
        }
        tailf:info "Reference to a VRF import policy.";
        description "Reference to a VRF import policy.";
      }
      leaf export-policy {
        type leafref {
          path "/l3vpn-ntw/vpn-profiles/valid-provider-identifiers/"
             + "routing-profile-identifier/id";
        }
        description
          "Reference to a VRF export policy.";
        tailf:info
          "Reference to a VRF export policy.";
      }
    }
  }
  grouping net-acc {
    container vpn-network-accesses {
      list vpn-network-access {
        key "id";
        leaf id {
          type l3vpn-svc:svc-id;
          description
            "Identifier for the access.";
          tailf:info
            "Identifier for the access.";
        }
        leaf port-id {
          type l3vpn-svc:svc-id;
          description
            "Port name. Example: Loopback1234;
            please refer to device configuration for supported values";
          tailf:info
            "Port name. Example: Loopback1234;
            please refer to device configuration for supported values";
        }
        // NSO-REMOVED START
        // leaf description {
        //   type string;
        //   description
        //     "Textual description of a VPN service.";
        // }
        // NSO-REMOVED END
        uses site-network-access-top-level-cfg;
        description
          "Configure the CE facing interface and routing information for this site";
        tailf:info
          "Configure the CE facing interface and routing information for this site";
      }
      tailf:info "Represents the point to which sites are connected.";
      description "Represents the point to which sites are connected.";
    }
    description "Main block of the Network Access.";
  }

  /* Main Blocks */

  container l3vpn-ntw {
    container vpn-profiles {
      uses vpn-profile-cfg;
      description
        "Container for VPN Profiles.";
      tailf:info
        "Container for VPN Profiles.";
    }
    container vpn-services {
      list vpn-service {
        key "vpn-id";
        uses service-status;
        uses vpn-svc-cfg;
        description
          "List of VPN services.";
        tailf:info
          "List of VPN services.";

        // NSO ADDITION START
        uses ncs:service-data;
        ncs:servicepoint ietf-l3vpn-ntw-servicepoint;

        tailf:validate "ietf-l3vpn-nm-validation" {
            tailf:dependency ".";
        }

        uses ct-hook:template-hook;

        tailf:action self-test {
          tailf:actionpoint ietf-l3vpn-nm-self-test-actionpoint;
          input {
          }
          output {
            leaf status {
              type string;
            }
            leaf message {
              type string;
            }
          }
        }
        tailf:action error-recovery {
          tailf:actionpoint ietf-l3vpn-nm-service-error-recovery;
          tailf:info "Action to recover a service during create/update from a transient failures
                      like device connection issues once the device is reachable again.
                      For create/update failures, this action issues a sync on the device
                      & redeploys the service with reconcile option.";
          description "Action to recover a service during create/update from a transient failures
                      like device connection issues once the device is reachable again.
                      For create/update failures, this action issues a sync on the device
                      & redeploys the service with reconcile option.";
          input {
            leaf sync-direction {
              tailf:info "sync device with sync-from or sync-to";
              description "sync device with sync-from or sync-to";
              type enumeration {
                enum sync-from;
                enum sync-to;
              }
              mandatory true;
            }
          }
          output {
            leaf success {
              type boolean;
              mandatory true;
            }
            leaf detail {
              type string;
            }
          }
          tailf:confirm-text "########################\n" +
            "#        Warning       #\n" +
            "########################\n" +
            "You are about to recover a T-SDN service.\n" +
            "This will issue a sync on the device.\n" +
            "Are you sure you want to proceed?" {
              tailf:confirm-default false;
          }
        }
        // NSO ADDITION END
      }

      // NSO ADDITION START
      list vpn-service-plan {
        config false;
        tailf:cdb-oper {
          tailf:persistent true;
        }
        key "vpn-id";
        leaf vpn-id {
          type string;
          description
          "VPN identifier. This identifier has a local meaning.";
          tailf:info
          "VPN identifier. This identifier has a local meaning.";
        }

        uses ncs:nano-plan-data;
        uses ncs:nano-plan-history;
	    }
	    // NSO ADDITION END

      description
        "Top-level container for the VPN services.";
    }
    description
      "Main container for L3VPN services management.";
  }

  // NSO ADDITION START
  container l3nm-actions {
    tailf:action cleanup {
      tailf:actionpoint ietf-l3vpn-nm-cleanup;
      tailf:info "Clean up L3NM service configuration and operational data";
      description "Clean up L3NM service configuration and operational data";
      input {
        leaf service {
          type string;
          mandatory true;
        }
        leaf vpn-node {
          tailf:info "Clean up L3NM service configuration for a given vpn-node";
          description "Clean up L3NM service configuration for a given vpn-node";
          type string;
        }
        leaf vpn-network-access-id {
          tailf:info "Clean up this vpn-node associated with vpn-network-access-id" +
                     "under given service.";
          description "Clean up this vpn-node associated with vpn-network-access-id" +
                      "under given service.";
          type string;
          mandatory true;
          when "../vpn-node";
        }
        leaf no-networking {
          type boolean;
          mandatory true;
        }
      }
      output {
        leaf success {
          type boolean;
          mandatory true;
        }
        leaf detail {
          type string;
        }
      }
      tailf:confirm-text "########################\n" +
        "#        Warning       #\n" +
        "########################\n" +
        "You are about to forcefully cleanup a T-SDN service.\n" +
        "This will affect the deploying service and leave network device(s) & NSO out-of-sync (for no-networking=true).\n" +
        "Are you sure you want to proceed?" {
          tailf:confirm-default false;
      }
    }
    tailf:action internal-plan-change-handler {
      tailf:hidden full;
      tailf:actionpoint ietf-l3vpn-nm-internal-plan-change-handler;
      input {
        uses kicker:action-input-params;
      }
      output {
      }
    }
    tailf:action error-recovery {
      tailf:actionpoint ietf-l3vpn-nm-fp-error-recovery;
      tailf:info "Action to recover a service during create/update/delete from a transient failures
                  like device connection issues once the device is reachable again.
                  For create/update failures, this action issues a sync on the device
                  & redeploys the service with reconcile option.
                  For delete failures, this action issues a sync on the device &
                  redeploys zombie services.";
      description "Action to recover a service during create/update/delete from a transient failures
                  like device connection issues once the device is reachable again.
                  For create/update failures, this action issues a sync on the device
                  & redeploys the service with reconcile option.
                  For delete failures, this action issues a sync on the device &
                  redeploys zombie services.";
      input {
        leaf service {
          tailf:info "Service to recover";
          description "Service to recover";
          type string;
          mandatory true;
        }
        leaf vpn-node {
          tailf:info "Recover this vpn-node under given service.";
          description "Recover this vpn-node under given service.";
          type string;
        }
        leaf vpn-network-access-id {
          tailf:info "Recover this vpn-node associated with vpn-network-access-id" +
                     "under given service.";
          description "Recover this vpn-node associated with vpn-network-access-id" +
                      "under given service.";
          type string;
          mandatory true;
          when "../vpn-node";
        }
        leaf sync-direction {
          tailf:info "sync device with sync-from or sync-to";
          description "sync device with sync-from or sync-to";
          type enumeration {
            enum sync-from;
            enum sync-to;
          }
          mandatory true;
        }
      }
      output {
        leaf success {
          type boolean;
          mandatory true;
        }
        leaf detail {
          type string;
        }
      }
      tailf:confirm-text "########################\n" +
        "#        Warning       #\n" +
        "########################\n" +
        "You are about to recover a T-SDN service.\n" +
        "This will issue a sync on the device.\n" +
        "Are you sure you want to proceed?" {
          tailf:confirm-default false;
      }
    }
  }

  augment /l3vpn-ntw/vpn-services/vpn-service-plan/plan {
    uses tsdn-core-fp-common:status-code-plan-augmentation;
  }

  augment /l3vpn-ntw/vpn-services/vpn-service-plan/plan-history {
    uses tsdn-core-fp-common:status-code-plan-augmentation;
  }

  augment /l3vpn-ntw/vpn-services/vpn-service-plan/plan/component {
    uses tsdn-core-fp-common:status-code-component-augmentation;
    uses tsdn-core-fp-common:static-config-redeploy-indicator-component-augmentation;
  }

  augment /l3vpn-ntw/vpn-services/vpn-service-plan/plan-history/plan/component {
    uses tsdn-core-fp-common:status-code-component-augmentation;
    uses tsdn-core-fp-common:static-config-redeploy-indicator-component-augmentation;
  }

  // NSO ADDITION END
}
