module tapi-streaming {
  // Generated by yanger -t ncs
  tailf:mount-id "onf-tapi-nc-2.0:onf-tapi-nc-2.0";
  tailf:ncs-device-type "netconf";

  yang-version 1.1;
  namespace "urn:onf:otcc:yang:tapi-streaming";
  prefix tapi-streaming;

  import tapi-common {
    prefix tapi-common;
  }
  import tapi-connectivity {
    prefix tapi-connectivity;
  }
  import tapi-equipment {
    prefix tapi-equipment;
  }
  import tapi-oam {
    prefix tapi-oam;
  }
  import tapi-path-computation {
    prefix tapi-path-computation;
  }
  import tapi-topology {
    prefix tapi-topology;
  }
  import tapi-virtual-network {
    prefix tapi-virtual-network;
  }
  import tailf-common {
    prefix tailf;
  }
  import tailf-ncs {
    prefix ncs;
  }

  organization
    "ONF OTCC (Open Transport Configuration & Control) Project";
  contact
    "
     Project Web: <https://urldefense.com/v3/__https://wiki.opennetworking.org/display/OTCC/TAPI__;!!OSsGDw!bx-l35NqfQHpJ8R_DmXfi2NX2ll5dMl9VbK5aS_m3ZShiVoz74Ur_yiFzE6g$ >
     Project List: <mailto:transport-api@opennetworking.org>
     Editor: Karthik Sethuraman <mailto:karthik.sethuraman@necam.com>
     Andrea Mazzin <mailto:andrea.mazzini@nokia.com>
     Arturo Mayoral <mailto:arturo.mayoral@telefonica.com>
     Nigel Davis <mailto:ndavis@ciena.com>";
  description
    "This module contains TAPI Streaming Model definitions.
     Source: TapiStreaming.uml
     - The TAPI YANG models included in this TAPI release are a *normative* part of the TAPI SDK.
     - The YANG specifications have been generated from the corresponding UML model using the [ONF EAGLE UML2YANG mapping tool]
     <https://urldefense.com/v3/__https://github.com/OpenNetworkingFoundation/EagleUmlYang__;!!OSsGDw!bx-l35NqfQHpJ8R_DmXfi2NX2ll5dMl9VbK5aS_m3ZShiVoz74Ur_6pxiNxl$ >
     and further edited manually to comply with the [ONF IISOMI UML2YANG mapping guidelines]
     <https://urldefense.com/v3/__https://wiki.opennetworking.org/display/OIMT/UML*-*YANG*Guidelines__;Kysr!!OSsGDw!bx-l35NqfQHpJ8R_DmXfi2NX2ll5dMl9VbK5aS_m3ZShiVoz74Ur_wxKUbJ_$ >
     - Status of YANG model artifacts can be determined by referring to the corresponding UML artifacts.
     As described in the UML models, some artifacts are considered *experimental*, and thus the corresponding YANG artifacts.
     - The ONF TAPI release process does not guarantee backward compatibility of YANG models across major versions of TAPI releases.
     The YANG model backward compatibility criteria are outlined in section 11 of <https://urldefense.com/v3/__https://tools.ietf.org/html/rfc7950__;!!OSsGDw!bx-l35NqfQHpJ8R_DmXfi2NX2ll5dMl9VbK5aS_m3ZShiVoz74Ur_zcAY1P4$ >.
     YANG models included in this release may not be backward compatible with previous TAPI releases.
     Copyright (c) 2018 Open Networking Foundation (ONF). All rights reserved.
     License: This module is distributed under the Apache License 2.0.";

  revision 2020-06-16 {
    description
      "ONF Transport API version 2.1.3.
       - Comment typos corrected.
       - One attribute changed (sourcePrecesion/source-precesion --> sourcePrecision/source-precision).
       Changes included in this TAPI release (v2.1.3) are listed in
       <https://urldefense.com/v3/__https://github.com/OpenNetworkingFoundation/TAPI/blob/develop_v2_1/CHANGE_LOG/change-log.2.1.3.md__;!!OSsGDw!bx-l35NqfQHpJ8R_DmXfi2NX2ll5dMl9VbK5aS_m3ZShiVoz74Ur_xm1nx_D$ >";
    reference
      "ONF-TR-527, ONF-TR-512, ONF-TR-531, RFC 7950, RFC 6087 and ONF TAPI UML model
       <https://urldefense.com/v3/__https://github.com/OpenNetworkingFoundation/TAPI/tree/v2.1.0/UML__;!!OSsGDw!bx-l35NqfQHpJ8R_DmXfi2NX2ll5dMl9VbK5aS_m3ZShiVoz74Ur_8UH3XnH$ >";
  }
  revision 2019-07-16 {
    description
      "ONF Transport API version 2.1.2.
       Changes included in this TAPI release (v2.1.2) are listed in
       <https://urldefense.com/v3/__https://github.com/OpenNetworkingFoundation/TAPI/blob/develop_v2_1/CHANGE_LOG/change-log.2.1.2.md__;!!OSsGDw!bx-l35NqfQHpJ8R_DmXfi2NX2ll5dMl9VbK5aS_m3ZShiVoz74Ur_0xFu4bN$ >";
    reference
      "ONF-TR-527, ONF-TR-512, ONF-TR-531, RFC 7950, RFC 6087 and ONF TAPI UML model
       <https://urldefense.com/v3/__https://github.com/OpenNetworkingFoundation/TAPI/tree/v2.1.0/UML__;!!OSsGDw!bx-l35NqfQHpJ8R_DmXfi2NX2ll5dMl9VbK5aS_m3ZShiVoz74Ur_8UH3XnH$ >";
  }
  revision 2018-12-10 {
    description
      "ONF Transport API version 2.1.1.
       Changes included in this TAPI release (v2.1.1) are listed in
       <https://urldefense.com/v3/__https://github.com/OpenNetworkingFoundation/TAPI/blob/develop/CHANGE_LOG/change-log.2.1.1.md__;!!OSsGDw!bx-l35NqfQHpJ8R_DmXfi2NX2ll5dMl9VbK5aS_m3ZShiVoz74Ur__2p0od1$ >";
    reference
      "ONF-TR-527, ONF-TR-512, ONF-TR-531, RFC 7950, RFC 6087 and ONF TAPI UML model
       <https://urldefense.com/v3/__https://github.com/OpenNetworkingFoundation/TAPI/tree/v2.1.0/UML__;!!OSsGDw!bx-l35NqfQHpJ8R_DmXfi2NX2ll5dMl9VbK5aS_m3ZShiVoz74Ur_8UH3XnH$ >";
  }
  revision 2018-10-16 {
    description
      "ONF Transport API version 2.1.0.
       Changes included in this TAPI release (v2.1.0) are listed in
       <https://urldefense.com/v3/__https://github.com/OpenNetworkingFoundation/TAPI/blob/develop/CHANGE_LOG/change-log.2.1.0.md__;!!OSsGDw!bx-l35NqfQHpJ8R_DmXfi2NX2ll5dMl9VbK5aS_m3ZShiVoz74Ur_4DGi8ul$ >";
    reference
      "ONF-TR-527, ONF-TR-512, ONF-TR-531, RFC 7950, RFC 6087 and ONF TAPI UML model
       <https://urldefense.com/v3/__https://github.com/OpenNetworkingFoundation/TAPI/tree/v2.1.0/UML__;!!OSsGDw!bx-l35NqfQHpJ8R_DmXfi2NX2ll5dMl9VbK5aS_m3ZShiVoz74Ur_8UH3XnH$ >";
  }
  revision 2018-03-07 {
    description
      "ONF Transport API version 2.0.2
       This YANG module has been generated from the TAPI UML Model using the IISOMI-Eagle xmi2yang mapping tool.
       Changes in this revision: <https://urldefense.com/v3/__https://github.com/OpenNetworkingFoundation/TAPI/blob/develop/CHANGE_LOG/change-log.2.0.2.md__;!!OSsGDw!bx-l35NqfQHpJ8R_DmXfi2NX2ll5dMl9VbK5aS_m3ZShiVoz74Ur_8KlxwJZ$ >";
    reference
      "ONF-TR-527, ONF-TR-512, ONF-TR-531, RFC 6020, RFC 6087 and ONF TAPI UML model
       <https://urldefense.com/v3/__https://github.com/OpenNetworkingFoundation/TAPI/tree/v2.0.2/UML__;!!OSsGDw!bx-l35NqfQHpJ8R_DmXfi2NX2ll5dMl9VbK5aS_m3ZShiVoz74Ur_-hMD5Xl$ >";
  }
  revision 2018-02-16 {
    description
      "ONF Transport API version 2.0.1
       This YANG module has been generated from the TAPI UML Model using the IISOMI-Eagle xmi2yang mapping tool.
       Changes in this revision: <https://urldefense.com/v3/__https://github.com/OpenNetworkingFoundation/TAPI/blob/develop/CHANGE_LOG/change-log.2.0.1.md__;!!OSsGDw!bx-l35NqfQHpJ8R_DmXfi2NX2ll5dMl9VbK5aS_m3ZShiVoz74Ur__C1vuym$ >";
    reference
      "ONF-TR-527, ONF-TR-512, ONF-TR-531, RFC 6020, RFC 6087 and ONF TAPI UML model
       <https://urldefense.com/v3/__https://github.com/OpenNetworkingFoundation/TAPI/tree/v2.0.1/UML__;!!OSsGDw!bx-l35NqfQHpJ8R_DmXfi2NX2ll5dMl9VbK5aS_m3ZShiVoz74Ur_5DYNwzZ$ >";
  }
  revision 2018-01-02 {
    description
      "ONF Transport API version 2.0.0
       This YANG module has been generated from the TAPI UML Model using the IISOMI-Eagle xmi2yang mapping tool.
       Changes in this revision: <https://urldefense.com/v3/__https://github.com/OpenNetworkingFoundation/TAPI/blob/develop/CHANGE_LOG/change-log.2.0.0.md__;!!OSsGDw!bx-l35NqfQHpJ8R_DmXfi2NX2ll5dMl9VbK5aS_m3ZShiVoz74Ur_1xZSBRA$ >";
    reference
      "ONF-TR-527, ONF-TR-512, ONF-TR-531, RFC 6020, RFC 6087 and ONF TAPI UML model
       <https://urldefense.com/v3/__https://github.com/OpenNetworkingFoundation/TAPI/tree/v2.0.0/UML__;!!OSsGDw!bx-l35NqfQHpJ8R_DmXfi2NX2ll5dMl9VbK5aS_m3ZShiVoz74Ur_xt-GtqY$ >";
  }

  typedef ncs_template_alarm-detector-state {
    type string;
    description
      "The state of the processed Boolean alarm detector.
       The source applies some analysis to the raw detector to determine the state.
       The processing by the source my vary.";
  }

  typedef ncs_template_log-record-strategy {
    type string;
    description
      "Defines the different approaches for logging information about an event covering the log trigger and the log content.";
  }

  typedef ncs_template_log-storage-strategy {
    type string;
    description
      "Defines the storage (record retention) approach.";
  }

  typedef ncs_template_object-class-identifier {
    type string;
    description
      "The list of TAPI Global Object Class types for which a record can be streamed.";
  }

  typedef ncs_template_stream-state {
    type string;
    description
      "The state of the available stream.";
  }

  typedef ncs_template_record-type {
    type string;
    description
      "The type of the record.
       Used to understand what log content will be present and how to interpret it.
       For some record types there is special encoding.
       A ACTIVE alarm and an INTERMITTENT alarm are CREATE_UPDATE.
       A CLEAR alarm is DELETE with an adjacent TOMBSTONE record.";
  }

  typedef ncs_template_source-precision {
    type string;
    description
      "Alternative statements about timing precision at the event source.";
  }

  typedef ncs_template_spread {
    type string;
    description
      "The alternative time of occurrence statements.";
  }

  typedef ncs_template_condition-detector-type {
    type string;
    description
      "The type of condition detector.
       The type relates to the characteristics of the detection and reporting strategies.
       This drives the conditional augment.";
  }

  typedef ncs_template_event-source {
    type string;
    description
      "Source of the event.
       Use to give some idea of the time characteristics of the event source.";
  }

  typedef ncs_template_perceived-severity {
    type string;
    description
      "The values for importance of an ACTIVE, INTERMITTENT or CLEAR alarm.";
  }

  typedef ncs_template_service-affect {
    type string;
    description
      "Indicates whether the device considers the condition to be impacting service.
       Note that the detected condition along with knowledge of the topology and protection provide a more suitable approach.";
  }

  typedef ncs_rpc_notif_alarm-detector-state {
    type identityref {
      base ALARM_DETECTOR_STATE;
    }
    description
      "The state of the processed Boolean alarm detector.
       The source applies some analysis to the raw detector to determine the state.
       The processing by the source my vary.";
  }

  typedef ncs_rpc_notif_log-record-strategy {
    type identityref {
      base LOG_RECORD_STRATEGY;
    }
    description
      "Defines the different approaches for logging information about an event covering the log trigger and the log content.";
  }

  typedef ncs_rpc_notif_log-storage-strategy {
    type identityref {
      base LOG_STORAGE_STRATEGY;
    }
    description
      "Defines the storage (record retention) approach.";
  }

  typedef ncs_rpc_notif_object-class-identifier {
    type enumeration {
      enum "NODE" {
        description
          "Node.
           A GlobalClass.";
      }
      enum "CONNECTION" {
        description
          "Connection.
           A GlobalClass.";
      }
      enum "LINK" {
        description
          "Link.
           A GlobalClass.";
      }
      enum "CONNECTION_END_POINT" {
        description
          "ConnectionEndPoint.
           A GlobalClass.";
      }
      enum "CONNECTIVITY_SERVICE" {
        description
          "ConnectivityService.
           A GlobalClass.";
      }
      enum "INTER_RULE_GROUP" {
        description
          "InterRuleGroup.
           A GlobalClass.";
      }
      enum "MAINTENANCE_ENTITY" {
        description
          "MaintenanceEntity.
           A GlobalClass.";
      }
      enum "MAINTENANCE_ENTITY_GROUP" {
        description
          "Meg.
           A GlobalClass.";
      }
      enum "MEG_END_POINT" {
        description
          "Mep.
           A LocalClass.
           For streaming this requires parentAddress (when reporting the entity alone) or a combination of measuredEntityUuid and measuredEntityLocalId when reporting conditions.";
      }
      enum "MEG_INTERMEDIATE_POINT" {
        description
          "Mip.
           A LocalClass.
           For streaming this requires parentAddress (when reporting the entity alone) or a combination of measuredEntityUuid and measuredEntityLocalId when reporting conditions. ";
      }
      enum "NODE_EDGE_POINT" {
        description
          "NodeEdgePoint.
           A GlobalClass.";
      }
      enum "OAM_JOB" {
        description
          "OamJob.
           A GlobalClass.";
      }
      enum "PATH" {
        description
          "Path.
           A GlobalClass.";
      }
      enum "NODE_RULE_GROUP" {
        description
          "NodeRuleGroup.
           A GlobalClass.";
      }
      enum "PATH_COMPUTATION_SERVICE" {
        description
          "PathComputationService.
           A GlobalClass.";
      }
      enum "ROUTE" {
        description
          "Route.
           A LocalClass.
           For streaming this requires parentAddress (when reporting the entity alone) or a combination of measuredEntityUuid and measuredEntityLocalId when reporting conditions";
      }
      enum "RULE" {
        description
          "Rule.
           A LocalClass.
           For streaming this requires parentAddress (when reporting the entity alone) or a combination of measuredEntityUuid and measuredEntityLocalId when reporting conditions";
      }
      enum "SERVICE_INTERFACE_POINT" {
        description
          "ServiceInterfacePoint.
           A GlobalClass.";
      }
      enum "SWITCH" {
        description
          "Switch.
           A LocalClass.
           For streaming this requires parentAddress (when reporting the entity alone) or a combination of measuredEntityUuid and measuredEntityLocalId when reporting conditions";
      }
      enum "SWITCH_CONTROL" {
        description
          "SwitchControl.
           A GlobalClass.";
      }
      enum "TOPOLOGY" {
        description
          "Topology.
           A GlobalClass.";
      }
      enum "VIRTUAL_NETWORK_SERVICE" {
        description
          "VirtualNetworkService.
           A GlobalClass.";
      }
      enum "OAM_PROFILE" {
        description
          "OamProfile.
           A GlobalClass.";
      }
      enum "OAM_SERVICE" {
        description
          "OamService.
           A GlobalClass.";
      }
      enum "CONNECTION_SPEC" {
        description
          "ConnectionSpec.
           A class that is a representation of the definition that an instance of a Connection references. This has a globally unique id.";
      }
      enum "ACCESS_PORT" {
        description
          "AccessPort.
           A GlobalClass.";
      }
      enum "DEVICE" {
        description
          "Device.
           A GlobalClass.";
      }
      enum "PHYSICAL_SPAN" {
        description
          "PhysicalSpan.
           A GlobalClass.";
      }
      enum "EQUIPMENT" {
        description
          "Equipment.
           A GlobalClass.";
      }
      enum "HOLDER" {
        description
          "Holder.
           A GlobalClass.";
      }
      enum "CONDITION_DETECTOR" {
        description
          "ConditionDetector.
           Has an id approach that allows for the measured entity to have a NativeId, or UUID or ID combination.";
      }
      enum "AVAILABLE_STREAM" {
        description
          "AvailableStream.
           A GlobalClass.";
      }
      enum "STREAM_MONITOR" {
        description
          "StreamMonitor.
           A GlobalClass.";
      }
      enum "SUPPORTED_STREAM_TYPE" {
        description
          "SupportedStream.
           A GlobalClass.";
      }
      enum "NETWORK_TOPOLOGY_SERVICE" {
        description
          "NetworkTopologyService.
           A GlobalClass.";
      }
      enum "TAPI_CONTEXT" {
        description
          "TapiContext.
           A GlobalClass.";
      }
      enum "OAM_SERVICE_END_POINT" {
        description
          "OamServiceEndPoint.
           Local class. For streaming this requires parentAddress (when reporting the entity alone) or a combination of measuredEntityUuid and measuredEntityLocalId when reporting conditions.";
      }
      enum "PM_BIN_DATA" {
        description
          "PmBinData.
           Local class. For streaming this requires parentAddress (when reporting the entity alone) or a combination of measuredEntityUuid and measuredEntityLocalId when reporting conditions.";
      }
      enum "PM_CURRENT_DATA" {
        description
          "PmCurrentData.
           Local class. For streaming this requires parentAddress (when reporting the entity alone) or a combination of measuredEntityUuid and measuredEntityLocalId when reporting conditions.";
      }
      enum "PM_HISTORY_DATA" {
        description
          "PmHistoryData.
           Local class. For streaming this requires parentAddress (when reporting the entity alone) or a combination of measuredEntityUuid and measuredEntityLocalId when reporting conditions.";
      }
      enum "PM_THRESHOLD_DATA" {
        description
          "PmThresholdData.
           Local class. For streaming this requires parentAddress (when reporting the entity alone) or a combination of measuredEntityUuid and measuredEntityLocalId when reporting conditions.";
      }
      enum "CONNECTIVITY_SERVICE_END_POINT" {
        description
          "ConnectivityServiceEndPoint.
           Local class. For streaming this requires parentAddress (when reporting the entity alone) or a combination of measuredEntityUuid and measuredEntityLocalId when reporting conditions.";
      }
      enum "ABSTRACT_STRAND" {
        description
          "AbstractStrand.
           Local class. For streaming this requires parentAddress (when reporting the entity alone) or a combination of measuredEntityUuid and measuredEntityLocalId when reporting conditions.";
      }
      enum "PATH_OBJECTIVE_FUNCTION" {
        description
          "PathObjectiveFunction.
           Local class. For streaming this requires parentAddress (when reporting the entity alone) or a combination of measuredEntityUuid and measuredEntityLocalId when reporting conditions.";
      }
      enum "PATH_OPTIMIZATION_CONSTRAINT" {
        description
          "PathOptimizationConstraint.
           Local class. For streaming this requires parentAddress (when reporting the entity alone) or a combination of measuredEntityUuid and measuredEntityLocalId when reporting conditions.";
      }
      enum "PATH_SERVICE_END_POINT" {
        description
          "PathServiceEndPoint.
           Local class. For streaming this requires parentAddress (when reporting the entity alone) or a combination of measuredEntityUuid and measuredEntityLocalId when reporting conditions.";
      }
      enum "VIRTUAL_NETWORK_CONSTRAINT" {
        description
          "VirtualNetworkConstraint.
           Local class. For streaming this requires parentAddress (when reporting the entity alone) or a combination of measuredEntityUuid and measuredEntityLocalId when reporting conditions.";
      }
      enum "VIRTUAL_NETWORK_SERVICE_END_POINT" {
        description
          "VirtualNetworkServiceEndPoint.
           Local class. For streaming this requires parentAddress (when reporting the entity alone) or a combination of measuredEntityUuid and measuredEntityLocalId when reporting conditions.";
      }
      enum "ANY_CLASS" {
        description
          "Empty structure.";
      }
    }
    description
      "The list of TAPI Global Object Class types for which a record can be streamed.";
  }

  typedef ncs_rpc_notif_stream-state {
    type identityref {
      base STREAM_STATE;
    }
    description
      "The state of the available stream.";
  }

  typedef ncs_rpc_notif_record-type {
    type identityref {
      base RECORD_TYPE;
    }
    description
      "The type of the record.
       Used to understand what log content will be present and how to interpret it.
       For some record types there is special encoding.
       A ACTIVE alarm and an INTERMITTENT alarm are CREATE_UPDATE.
       A CLEAR alarm is DELETE with an adjacent TOMBSTONE record.";
  }

  typedef ncs_rpc_notif_source-precision {
    type identityref {
      base SOURCE_PRECISION;
    }
    description
      "Alternative statements about timing precision at the event source.";
  }

  typedef ncs_rpc_notif_spread {
    type identityref {
      base SPREAD;
    }
    description
      "The alternative time of occurrence statements.";
  }

  typedef ncs_rpc_notif_condition-detector-type {
    type identityref {
      base CONDITION_DETECTOR_TYPE;
    }
    description
      "The type of condition detector.
       The type relates to the characteristics of the detection and reporting strategies.
       This drives the conditional augment.";
  }

  typedef ncs_rpc_notif_event-source {
    type enumeration {
      enum "RESOURCE_OPERATION" {
        description
          "The event is from the operation of the network resources.
           The event source has a relatively fast time characteristic.";
      }
      enum "MANAGEMENT_OPERATION" {
        description
          "Event is from a Management operation (slow control).
           The event source has a relatively slow time characteristic.";
      }
      enum "UNKNOWN" {
        description
          "The origin of the event is not known.";
      }
    }
    description
      "Source of the event.
       Use to give some idea of the time characteristics of the event source.";
  }

  typedef ncs_rpc_notif_perceived-severity {
    type enumeration {
      enum "CRITICAL" {
        description
          "The highest severity of ACTIVE/INTERMITTENT alarm.";
      }
      enum "MAJOR" {
        description
          "The middle severity of ACTIVE/INTERMITTENT alarm.";
      }
      enum "MINOR" {
        description
          "The lowest severity of ACTIVE/INTERMITTENT alarm.";
      }
      enum "WARNING" {
        description
          "An extremely low importance ACTIVE/INTERMITTENT alarm (lower than MINOR).";
      }
      enum "CLEARED" {
        description
          "The severity of a CLEAR where no other severity information is available.";
      }
    }
    description
      "The values for importance of an ACTIVE, INTERMITTENT or CLEAR alarm.";
  }

  typedef ncs_rpc_notif_service-affect {
    type enumeration {
      enum "SERVICE_AFFECTING" {
        description
          "The condition is believed to impact service.";
      }
      enum "NOT_SERVICE_AFFECTING" {
        description
          "The condition is believed to not impact service.";
      }
      enum "UNKNOWN" {
        description
          "The service impact of the condition is not known.";
      }
    }
    description
      "Indicates whether the device considers the condition to be impacting service.
       Note that the detected condition along with knowledge of the topology and protection provide a more suitable approach.";
  }

  typedef live_ncs_alarm-detector-state {
    type identityref {
      base ALARM_DETECTOR_STATE;
    }
    description
      "The state of the processed Boolean alarm detector.
       The source applies some analysis to the raw detector to determine the state.
       The processing by the source my vary.";
  }

  typedef live_ncs_log-record-strategy {
    type identityref {
      base LOG_RECORD_STRATEGY;
    }
    description
      "Defines the different approaches for logging information about an event covering the log trigger and the log content.";
  }

  typedef live_ncs_log-storage-strategy {
    type identityref {
      base LOG_STORAGE_STRATEGY;
    }
    description
      "Defines the storage (record retention) approach.";
  }

  typedef live_ncs_object-class-identifier {
    type enumeration {
      enum "NODE" {
        description
          "Node.
           A GlobalClass.";
      }
      enum "CONNECTION" {
        description
          "Connection.
           A GlobalClass.";
      }
      enum "LINK" {
        description
          "Link.
           A GlobalClass.";
      }
      enum "CONNECTION_END_POINT" {
        description
          "ConnectionEndPoint.
           A GlobalClass.";
      }
      enum "CONNECTIVITY_SERVICE" {
        description
          "ConnectivityService.
           A GlobalClass.";
      }
      enum "INTER_RULE_GROUP" {
        description
          "InterRuleGroup.
           A GlobalClass.";
      }
      enum "MAINTENANCE_ENTITY" {
        description
          "MaintenanceEntity.
           A GlobalClass.";
      }
      enum "MAINTENANCE_ENTITY_GROUP" {
        description
          "Meg.
           A GlobalClass.";
      }
      enum "MEG_END_POINT" {
        description
          "Mep.
           A LocalClass.
           For streaming this requires parentAddress (when reporting the entity alone) or a combination of measuredEntityUuid and measuredEntityLocalId when reporting conditions.";
      }
      enum "MEG_INTERMEDIATE_POINT" {
        description
          "Mip.
           A LocalClass.
           For streaming this requires parentAddress (when reporting the entity alone) or a combination of measuredEntityUuid and measuredEntityLocalId when reporting conditions. ";
      }
      enum "NODE_EDGE_POINT" {
        description
          "NodeEdgePoint.
           A GlobalClass.";
      }
      enum "OAM_JOB" {
        description
          "OamJob.
           A GlobalClass.";
      }
      enum "PATH" {
        description
          "Path.
           A GlobalClass.";
      }
      enum "NODE_RULE_GROUP" {
        description
          "NodeRuleGroup.
           A GlobalClass.";
      }
      enum "PATH_COMPUTATION_SERVICE" {
        description
          "PathComputationService.
           A GlobalClass.";
      }
      enum "ROUTE" {
        description
          "Route.
           A LocalClass.
           For streaming this requires parentAddress (when reporting the entity alone) or a combination of measuredEntityUuid and measuredEntityLocalId when reporting conditions";
      }
      enum "RULE" {
        description
          "Rule.
           A LocalClass.
           For streaming this requires parentAddress (when reporting the entity alone) or a combination of measuredEntityUuid and measuredEntityLocalId when reporting conditions";
      }
      enum "SERVICE_INTERFACE_POINT" {
        description
          "ServiceInterfacePoint.
           A GlobalClass.";
      }
      enum "SWITCH" {
        description
          "Switch.
           A LocalClass.
           For streaming this requires parentAddress (when reporting the entity alone) or a combination of measuredEntityUuid and measuredEntityLocalId when reporting conditions";
      }
      enum "SWITCH_CONTROL" {
        description
          "SwitchControl.
           A GlobalClass.";
      }
      enum "TOPOLOGY" {
        description
          "Topology.
           A GlobalClass.";
      }
      enum "VIRTUAL_NETWORK_SERVICE" {
        description
          "VirtualNetworkService.
           A GlobalClass.";
      }
      enum "OAM_PROFILE" {
        description
          "OamProfile.
           A GlobalClass.";
      }
      enum "OAM_SERVICE" {
        description
          "OamService.
           A GlobalClass.";
      }
      enum "CONNECTION_SPEC" {
        description
          "ConnectionSpec.
           A class that is a representation of the definition that an instance of a Connection references. This has a globally unique id.";
      }
      enum "ACCESS_PORT" {
        description
          "AccessPort.
           A GlobalClass.";
      }
      enum "DEVICE" {
        description
          "Device.
           A GlobalClass.";
      }
      enum "PHYSICAL_SPAN" {
        description
          "PhysicalSpan.
           A GlobalClass.";
      }
      enum "EQUIPMENT" {
        description
          "Equipment.
           A GlobalClass.";
      }
      enum "HOLDER" {
        description
          "Holder.
           A GlobalClass.";
      }
      enum "CONDITION_DETECTOR" {
        description
          "ConditionDetector.
           Has an id approach that allows for the measured entity to have a NativeId, or UUID or ID combination.";
      }
      enum "AVAILABLE_STREAM" {
        description
          "AvailableStream.
           A GlobalClass.";
      }
      enum "STREAM_MONITOR" {
        description
          "StreamMonitor.
           A GlobalClass.";
      }
      enum "SUPPORTED_STREAM_TYPE" {
        description
          "SupportedStream.
           A GlobalClass.";
      }
      enum "NETWORK_TOPOLOGY_SERVICE" {
        description
          "NetworkTopologyService.
           A GlobalClass.";
      }
      enum "TAPI_CONTEXT" {
        description
          "TapiContext.
           A GlobalClass.";
      }
      enum "OAM_SERVICE_END_POINT" {
        description
          "OamServiceEndPoint.
           Local class. For streaming this requires parentAddress (when reporting the entity alone) or a combination of measuredEntityUuid and measuredEntityLocalId when reporting conditions.";
      }
      enum "PM_BIN_DATA" {
        description
          "PmBinData.
           Local class. For streaming this requires parentAddress (when reporting the entity alone) or a combination of measuredEntityUuid and measuredEntityLocalId when reporting conditions.";
      }
      enum "PM_CURRENT_DATA" {
        description
          "PmCurrentData.
           Local class. For streaming this requires parentAddress (when reporting the entity alone) or a combination of measuredEntityUuid and measuredEntityLocalId when reporting conditions.";
      }
      enum "PM_HISTORY_DATA" {
        description
          "PmHistoryData.
           Local class. For streaming this requires parentAddress (when reporting the entity alone) or a combination of measuredEntityUuid and measuredEntityLocalId when reporting conditions.";
      }
      enum "PM_THRESHOLD_DATA" {
        description
          "PmThresholdData.
           Local class. For streaming this requires parentAddress (when reporting the entity alone) or a combination of measuredEntityUuid and measuredEntityLocalId when reporting conditions.";
      }
      enum "CONNECTIVITY_SERVICE_END_POINT" {
        description
          "ConnectivityServiceEndPoint.
           Local class. For streaming this requires parentAddress (when reporting the entity alone) or a combination of measuredEntityUuid and measuredEntityLocalId when reporting conditions.";
      }
      enum "ABSTRACT_STRAND" {
        description
          "AbstractStrand.
           Local class. For streaming this requires parentAddress (when reporting the entity alone) or a combination of measuredEntityUuid and measuredEntityLocalId when reporting conditions.";
      }
      enum "PATH_OBJECTIVE_FUNCTION" {
        description
          "PathObjectiveFunction.
           Local class. For streaming this requires parentAddress (when reporting the entity alone) or a combination of measuredEntityUuid and measuredEntityLocalId when reporting conditions.";
      }
      enum "PATH_OPTIMIZATION_CONSTRAINT" {
        description
          "PathOptimizationConstraint.
           Local class. For streaming this requires parentAddress (when reporting the entity alone) or a combination of measuredEntityUuid and measuredEntityLocalId when reporting conditions.";
      }
      enum "PATH_SERVICE_END_POINT" {
        description
          "PathServiceEndPoint.
           Local class. For streaming this requires parentAddress (when reporting the entity alone) or a combination of measuredEntityUuid and measuredEntityLocalId when reporting conditions.";
      }
      enum "VIRTUAL_NETWORK_CONSTRAINT" {
        description
          "VirtualNetworkConstraint.
           Local class. For streaming this requires parentAddress (when reporting the entity alone) or a combination of measuredEntityUuid and measuredEntityLocalId when reporting conditions.";
      }
      enum "VIRTUAL_NETWORK_SERVICE_END_POINT" {
        description
          "VirtualNetworkServiceEndPoint.
           Local class. For streaming this requires parentAddress (when reporting the entity alone) or a combination of measuredEntityUuid and measuredEntityLocalId when reporting conditions.";
      }
      enum "ANY_CLASS" {
        description
          "Empty structure.";
      }
    }
    description
      "The list of TAPI Global Object Class types for which a record can be streamed.";
  }

  typedef live_ncs_stream-state {
    type identityref {
      base STREAM_STATE;
    }
    description
      "The state of the available stream.";
  }

  typedef live_ncs_record-type {
    type identityref {
      base RECORD_TYPE;
    }
    description
      "The type of the record.
       Used to understand what log content will be present and how to interpret it.
       For some record types there is special encoding.
       A ACTIVE alarm and an INTERMITTENT alarm are CREATE_UPDATE.
       A CLEAR alarm is DELETE with an adjacent TOMBSTONE record.";
  }

  typedef live_ncs_source-precision {
    type identityref {
      base SOURCE_PRECISION;
    }
    description
      "Alternative statements about timing precision at the event source.";
  }

  typedef live_ncs_spread {
    type identityref {
      base SPREAD;
    }
    description
      "The alternative time of occurrence statements.";
  }

  typedef live_ncs_condition-detector-type {
    type identityref {
      base CONDITION_DETECTOR_TYPE;
    }
    description
      "The type of condition detector.
       The type relates to the characteristics of the detection and reporting strategies.
       This drives the conditional augment.";
  }

  typedef live_ncs_event-source {
    type enumeration {
      enum "RESOURCE_OPERATION" {
        description
          "The event is from the operation of the network resources.
           The event source has a relatively fast time characteristic.";
      }
      enum "MANAGEMENT_OPERATION" {
        description
          "Event is from a Management operation (slow control).
           The event source has a relatively slow time characteristic.";
      }
      enum "UNKNOWN" {
        description
          "The origin of the event is not known.";
      }
    }
    description
      "Source of the event.
       Use to give some idea of the time characteristics of the event source.";
  }

  typedef live_ncs_perceived-severity {
    type enumeration {
      enum "CRITICAL" {
        description
          "The highest severity of ACTIVE/INTERMITTENT alarm.";
      }
      enum "MAJOR" {
        description
          "The middle severity of ACTIVE/INTERMITTENT alarm.";
      }
      enum "MINOR" {
        description
          "The lowest severity of ACTIVE/INTERMITTENT alarm.";
      }
      enum "WARNING" {
        description
          "An extremely low importance ACTIVE/INTERMITTENT alarm (lower than MINOR).";
      }
      enum "CLEARED" {
        description
          "The severity of a CLEAR where no other severity information is available.";
      }
    }
    description
      "The values for importance of an ACTIVE, INTERMITTENT or CLEAR alarm.";
  }

  typedef live_ncs_service-affect {
    type enumeration {
      enum "SERVICE_AFFECTING" {
        description
          "The condition is believed to impact service.";
      }
      enum "NOT_SERVICE_AFFECTING" {
        description
          "The condition is believed to not impact service.";
      }
      enum "UNKNOWN" {
        description
          "The service impact of the condition is not known.";
      }
    }
    description
      "Indicates whether the device considers the condition to be impacting service.
       Note that the detected condition along with knowledge of the topology and protection provide a more suitable approach.";
  }

  typedef alarm-detector-state {
    type identityref {
      base ALARM_DETECTOR_STATE;
    }
    description
      "The state of the processed Boolean alarm detector.
       The source applies some analysis to the raw detector to determine the state.
       The processing by the source my vary.";
  }

  typedef log-record-strategy {
    type identityref {
      base LOG_RECORD_STRATEGY;
    }
    description
      "Defines the different approaches for logging information about an event covering the log trigger and the log content.";
  }

  typedef log-storage-strategy {
    type identityref {
      base LOG_STORAGE_STRATEGY;
    }
    description
      "Defines the storage (record retention) approach.";
  }

  typedef object-class-identifier {
    type enumeration {
      enum "NODE" {
        description
          "Node.
           A GlobalClass.";
      }
      enum "CONNECTION" {
        description
          "Connection.
           A GlobalClass.";
      }
      enum "LINK" {
        description
          "Link.
           A GlobalClass.";
      }
      enum "CONNECTION_END_POINT" {
        description
          "ConnectionEndPoint.
           A GlobalClass.";
      }
      enum "CONNECTIVITY_SERVICE" {
        description
          "ConnectivityService.
           A GlobalClass.";
      }
      enum "INTER_RULE_GROUP" {
        description
          "InterRuleGroup.
           A GlobalClass.";
      }
      enum "MAINTENANCE_ENTITY" {
        description
          "MaintenanceEntity.
           A GlobalClass.";
      }
      enum "MAINTENANCE_ENTITY_GROUP" {
        description
          "Meg.
           A GlobalClass.";
      }
      enum "MEG_END_POINT" {
        description
          "Mep.
           A LocalClass.
           For streaming this requires parentAddress (when reporting the entity alone) or a combination of measuredEntityUuid and measuredEntityLocalId when reporting conditions.";
      }
      enum "MEG_INTERMEDIATE_POINT" {
        description
          "Mip.
           A LocalClass.
           For streaming this requires parentAddress (when reporting the entity alone) or a combination of measuredEntityUuid and measuredEntityLocalId when reporting conditions. ";
      }
      enum "NODE_EDGE_POINT" {
        description
          "NodeEdgePoint.
           A GlobalClass.";
      }
      enum "OAM_JOB" {
        description
          "OamJob.
           A GlobalClass.";
      }
      enum "PATH" {
        description
          "Path.
           A GlobalClass.";
      }
      enum "NODE_RULE_GROUP" {
        description
          "NodeRuleGroup.
           A GlobalClass.";
      }
      enum "PATH_COMPUTATION_SERVICE" {
        description
          "PathComputationService.
           A GlobalClass.";
      }
      enum "ROUTE" {
        description
          "Route.
           A LocalClass.
           For streaming this requires parentAddress (when reporting the entity alone) or a combination of measuredEntityUuid and measuredEntityLocalId when reporting conditions";
      }
      enum "RULE" {
        description
          "Rule.
           A LocalClass.
           For streaming this requires parentAddress (when reporting the entity alone) or a combination of measuredEntityUuid and measuredEntityLocalId when reporting conditions";
      }
      enum "SERVICE_INTERFACE_POINT" {
        description
          "ServiceInterfacePoint.
           A GlobalClass.";
      }
      enum "SWITCH" {
        description
          "Switch.
           A LocalClass.
           For streaming this requires parentAddress (when reporting the entity alone) or a combination of measuredEntityUuid and measuredEntityLocalId when reporting conditions";
      }
      enum "SWITCH_CONTROL" {
        description
          "SwitchControl.
           A GlobalClass.";
      }
      enum "TOPOLOGY" {
        description
          "Topology.
           A GlobalClass.";
      }
      enum "VIRTUAL_NETWORK_SERVICE" {
        description
          "VirtualNetworkService.
           A GlobalClass.";
      }
      enum "OAM_PROFILE" {
        description
          "OamProfile.
           A GlobalClass.";
      }
      enum "OAM_SERVICE" {
        description
          "OamService.
           A GlobalClass.";
      }
      enum "CONNECTION_SPEC" {
        description
          "ConnectionSpec.
           A class that is a representation of the definition that an instance of a Connection references. This has a globally unique id.";
      }
      enum "ACCESS_PORT" {
        description
          "AccessPort.
           A GlobalClass.";
      }
      enum "DEVICE" {
        description
          "Device.
           A GlobalClass.";
      }
      enum "PHYSICAL_SPAN" {
        description
          "PhysicalSpan.
           A GlobalClass.";
      }
      enum "EQUIPMENT" {
        description
          "Equipment.
           A GlobalClass.";
      }
      enum "HOLDER" {
        description
          "Holder.
           A GlobalClass.";
      }
      enum "CONDITION_DETECTOR" {
        description
          "ConditionDetector.
           Has an id approach that allows for the measured entity to have a NativeId, or UUID or ID combination.";
      }
      enum "AVAILABLE_STREAM" {
        description
          "AvailableStream.
           A GlobalClass.";
      }
      enum "STREAM_MONITOR" {
        description
          "StreamMonitor.
           A GlobalClass.";
      }
      enum "SUPPORTED_STREAM_TYPE" {
        description
          "SupportedStream.
           A GlobalClass.";
      }
      enum "NETWORK_TOPOLOGY_SERVICE" {
        description
          "NetworkTopologyService.
           A GlobalClass.";
      }
      enum "TAPI_CONTEXT" {
        description
          "TapiContext.
           A GlobalClass.";
      }
      enum "OAM_SERVICE_END_POINT" {
        description
          "OamServiceEndPoint.
           Local class. For streaming this requires parentAddress (when reporting the entity alone) or a combination of measuredEntityUuid and measuredEntityLocalId when reporting conditions.";
      }
      enum "PM_BIN_DATA" {
        description
          "PmBinData.
           Local class. For streaming this requires parentAddress (when reporting the entity alone) or a combination of measuredEntityUuid and measuredEntityLocalId when reporting conditions.";
      }
      enum "PM_CURRENT_DATA" {
        description
          "PmCurrentData.
           Local class. For streaming this requires parentAddress (when reporting the entity alone) or a combination of measuredEntityUuid and measuredEntityLocalId when reporting conditions.";
      }
      enum "PM_HISTORY_DATA" {
        description
          "PmHistoryData.
           Local class. For streaming this requires parentAddress (when reporting the entity alone) or a combination of measuredEntityUuid and measuredEntityLocalId when reporting conditions.";
      }
      enum "PM_THRESHOLD_DATA" {
        description
          "PmThresholdData.
           Local class. For streaming this requires parentAddress (when reporting the entity alone) or a combination of measuredEntityUuid and measuredEntityLocalId when reporting conditions.";
      }
      enum "CONNECTIVITY_SERVICE_END_POINT" {
        description
          "ConnectivityServiceEndPoint.
           Local class. For streaming this requires parentAddress (when reporting the entity alone) or a combination of measuredEntityUuid and measuredEntityLocalId when reporting conditions.";
      }
      enum "ABSTRACT_STRAND" {
        description
          "AbstractStrand.
           Local class. For streaming this requires parentAddress (when reporting the entity alone) or a combination of measuredEntityUuid and measuredEntityLocalId when reporting conditions.";
      }
      enum "PATH_OBJECTIVE_FUNCTION" {
        description
          "PathObjectiveFunction.
           Local class. For streaming this requires parentAddress (when reporting the entity alone) or a combination of measuredEntityUuid and measuredEntityLocalId when reporting conditions.";
      }
      enum "PATH_OPTIMIZATION_CONSTRAINT" {
        description
          "PathOptimizationConstraint.
           Local class. For streaming this requires parentAddress (when reporting the entity alone) or a combination of measuredEntityUuid and measuredEntityLocalId when reporting conditions.";
      }
      enum "PATH_SERVICE_END_POINT" {
        description
          "PathServiceEndPoint.
           Local class. For streaming this requires parentAddress (when reporting the entity alone) or a combination of measuredEntityUuid and measuredEntityLocalId when reporting conditions.";
      }
      enum "VIRTUAL_NETWORK_CONSTRAINT" {
        description
          "VirtualNetworkConstraint.
           Local class. For streaming this requires parentAddress (when reporting the entity alone) or a combination of measuredEntityUuid and measuredEntityLocalId when reporting conditions.";
      }
      enum "VIRTUAL_NETWORK_SERVICE_END_POINT" {
        description
          "VirtualNetworkServiceEndPoint.
           Local class. For streaming this requires parentAddress (when reporting the entity alone) or a combination of measuredEntityUuid and measuredEntityLocalId when reporting conditions.";
      }
      enum "ANY_CLASS" {
        description
          "Empty structure.";
      }
    }
    description
      "The list of TAPI Global Object Class types for which a record can be streamed.";
  }

  typedef stream-state {
    type identityref {
      base STREAM_STATE;
    }
    description
      "The state of the available stream.";
  }

  typedef record-type {
    type identityref {
      base RECORD_TYPE;
    }
    description
      "The type of the record.
       Used to understand what log content will be present and how to interpret it.
       For some record types there is special encoding.
       A ACTIVE alarm and an INTERMITTENT alarm are CREATE_UPDATE.
       A CLEAR alarm is DELETE with an adjacent TOMBSTONE record.";
  }

  typedef source-precision {
    type identityref {
      base SOURCE_PRECISION;
    }
    description
      "Alternative statements about timing precision at the event source.";
  }

  typedef spread {
    type identityref {
      base SPREAD;
    }
    description
      "The alternative time of occurrence statements.";
  }

  typedef condition-detector-type {
    type identityref {
      base CONDITION_DETECTOR_TYPE;
    }
    description
      "The type of condition detector.
       The type relates to the characteristics of the detection and reporting strategies.
       This drives the conditional augment.";
  }

  typedef event-source {
    type enumeration {
      enum "RESOURCE_OPERATION" {
        description
          "The event is from the operation of the network resources.
           The event source has a relatively fast time characteristic.";
      }
      enum "MANAGEMENT_OPERATION" {
        description
          "Event is from a Management operation (slow control).
           The event source has a relatively slow time characteristic.";
      }
      enum "UNKNOWN" {
        description
          "The origin of the event is not known.";
      }
    }
    description
      "Source of the event.
       Use to give some idea of the time characteristics of the event source.";
  }

  typedef perceived-severity {
    type enumeration {
      enum "CRITICAL" {
        description
          "The highest severity of ACTIVE/INTERMITTENT alarm.";
      }
      enum "MAJOR" {
        description
          "The middle severity of ACTIVE/INTERMITTENT alarm.";
      }
      enum "MINOR" {
        description
          "The lowest severity of ACTIVE/INTERMITTENT alarm.";
      }
      enum "WARNING" {
        description
          "An extremely low importance ACTIVE/INTERMITTENT alarm (lower than MINOR).";
      }
      enum "CLEARED" {
        description
          "The severity of a CLEAR where no other severity information is available.";
      }
    }
    description
      "The values for importance of an ACTIVE, INTERMITTENT or CLEAR alarm.";
  }

  typedef service-affect {
    type enumeration {
      enum "SERVICE_AFFECTING" {
        description
          "The condition is believed to impact service.";
      }
      enum "NOT_SERVICE_AFFECTING" {
        description
          "The condition is believed to not impact service.";
      }
      enum "UNKNOWN" {
        description
          "The service impact of the condition is not known.";
      }
    }
    description
      "Indicates whether the device considers the condition to be impacting service.
       Note that the detected condition along with knowledge of the topology and protection provide a more suitable approach.";
  }

  grouping ncs_template_available-stream-ref {
    leaf available-stream-uuid {
      type string;
      description
        "none";
    }
    description
      "none";
  }

  grouping ncs_template_supported-stream-type-ref {
    leaf supported-stream-type-uuid {
      type string;
      description
        "none";
    }
    description
      "none";
  }

  grouping ncs_template_legacy-properties {
    leaf perceived-severity {
      type ncs_template_perceived-severity;
      description
        "A device will provide an indication of importance for each alarm.
         This property indicates the importance.
         In some cases, the severity may change through the life of an active alarm.";
    }
    leaf service-affect {
      type ncs_template_service-affect;
      description
        "Some devices will indicate, from its very narrow viewpoint, whether service has been impacted or not.
         This property carries this detail.";
    }
    leaf is-acknowledged {
      type string;
      description
        "Devices offer a capability to acknowledge alarms (to stop the bells ringing).
         Often an EMS will offer a similar capability.
         This property reflects the current acknowledge state.";
    }
    leaf-list additional-alarm-info {
      // NCS patched for predictable order
      ordered-by user;
      type string;
      description
        "Often, alarms raised by devices have additional information.
         This property can be used to convey this.";
    }
    description
      "At this point in the evolution of control solutions LegacyProperties are probably mandatory, however, it is anticipated that as control solutions advance the LegacyProperties will become irrelevant.";
  }

  grouping ncs_template_approx-date-and-time {
    // NCS drop config false leaf 'primary-time-stamp'
    // NCS drop config false leaf 'start-time-stamp'
    // NCS drop config false leaf spread
    // NCS drop config false leaf 'source-precision'
    description
      "Allows for recording of an aspect of imprecise time.";
  }

  grouping ncs_template_compacted-log-details {
    // NCS drop config false leaf 'tombstone-retention'
    // NCS drop config false leaf 'compaction-delay'
    description
      "Details relevant for a CompactedLog.
       The essential Compacted Log strategy is to remove historic records about a particular thing such that only the latest record about each thing exists in the log.
       The essential strategy is refined by the parameters of this structure.";
  }

  grouping ncs_template_alarm-condition-detector-detail {
    // NCS drop config false leaf 'alarm-detector-state'
    // NCS drop config false container 'legacy-properties'
    description
      "A record of the state of a detector where that detector has two underling states that are of asymmetric importance.";
  }

  grouping ncs_template_condition-detector {
    // NCS drop config false leaf 'condition-native-name'
    // NCS drop config false leaf 'measured-entity-uuid'
    // NCS drop config false leaf 'measured-entity-native-id'
    // NCS drop config false leaf 'condition-normalized-name'
    // NCS drop config false leaf 'measured-entity-class'
    // NCS drop config false leaf 'detector-uuid'
    // NCS drop config false leaf 'detector-native-id'
    // NCS drop config false leaf 'condition-detector-type'
    // NCS drop config false leaf-list 'measured-entity-local-id'
    description
      "ConditionDetector represents any monitoring component that assesses properties of something and determines from those properties what conditions are associated with the thing.
       For example, a thing might be 'too hot' or might be 'unreliable'.
       The monitor may a multi-state output.
       The ConditionDetector lifecycle depends upon the lifecycle of the thing it is monitoring (this is a general OAM model consideration).
       The entityKey in the AppendLogRecordHeader for a ConditionDetector record is the nativeDetector Id which may be derived from other ids (most robustly, nativeOwningEntityName (to which the detector is associated) + natveConditionName).";
  }

  grouping ncs_template_any-class {
    description
      "In the final version all classes that can stream will be explicitly associated with the AppendLogRecordBody";
  }

  grouping ncs_template_stream-admin-context {
    // NCS drop config false list 'stream-monitor'
    uses tapi-common:ncs_template_global-class;
    description
      "Context providing access to stream administration functionality.";
  }

  grouping ncs_template_stream-monitor {
    // NCS drop config false leaf 'id-of-last-record-read-from-log'
    // NCS drop config false leaf 'id-of-last-record-written-to-log'
    // NCS drop config false container 'available-stream'
    // NCS drop config false leaf 'client-id'
    // NCS drop config false leaf 'last-updated'
    // NCS drop config false leaf 'client-address'
    uses tapi-common:ncs_template_global-class;
    description
      "Information on the monitoring of the use of a specific AvailableStream.";
  }

  grouping ncs_template_connection-protocol-details {
    // NCS drop config false leaf-list 'allowed-connection-protocols'
    description
      "Details of the connection protocols available for the specific stream.";
  }

  grouping ncs_template_available-stream {
    // NCS drop config false leaf 'connection-address'
    // NCS drop config false leaf 'stream-state'
    // NCS drop config false container 'supported-stream-type'
    // NCS drop config false leaf 'stream-id'
    // NCS drop config false leaf 'connection-protocol'
    uses tapi-common:ncs_template_global-class;
    description
      "Details of stream a stream that can be connected to by a client application.";
  }

  grouping ncs_template_stream-context {
    // NCS drop config false list 'available-stream'
    // NCS drop config false list 'supported-stream-type'
    description
      "All streams relevant to the specific TapiContext.";
  }

  grouping ncs_template_supported-stream-type {
    // NCS drop config false leaf 'stream-type-name'
    // NCS drop config false leaf 'record-retention'
    // NCS drop config false leaf 'segment-size'
    leaf-list record-content {
      // NCS patched for predictable order
      ordered-by user;
      type ncs_template_object-class-identifier;
      description
        "Identifies the classes that are supported through the stream.
         The list may be a subset of the classes within the context.";
    }
    // NCS drop config false leaf 'log-storage-strategy'
    // NCS drop config false leaf 'log-record-strategy'
    uses tapi-common:ncs_template_global-class;
    description
      "Definition of a supported stream type.";
  }

  grouping ncs_template_log-record {
    // NCS drop config false container 'log-record-header'
    // NCS drop config false container 'log-record-body'
    description
      "A specific atomic entry in a log.";
  }

  grouping ncs_template_log-record-body {
    // NCS drop config false container 'event-time-stamp'
    // NCS drop config false leaf 'event-source'
    // NCS drop config false list 'additional-event-info'
    // NCS drop config false leaf-list 'parent-address'
    // NCS drop config false leaf 'record-content'
    description
      "The specific details of the Record.";
  }

  grouping ncs_template_log-record-header {
    // NCS drop config false leaf 'tapi-context'
    // NCS drop config false leaf token
    // NCS drop config false list 'full-log-record-offset-id'
    // NCS drop config false leaf 'log-append-time-stamp'
    // NCS drop config false leaf 'entity-key'
    // NCS drop config false leaf 'record-type'
    // NCS drop config false leaf 'record-authenticity-token'
    description
      "The header of the log record providing general parameters of the record common to all records.";
  }

  grouping ncs_template_stream-record {
    // NCS drop config false list 'log-record'
    description
      "The stream content.";
  }

  grouping ncs_rpc_notif_available-stream-ref {
    leaf available-stream-uuid {
      type string;
      description
        "none";
    }
    description
      "none";
  }

  grouping ncs_rpc_notif_supported-stream-type-ref {
    leaf supported-stream-type-uuid {
      type string;
      description
        "none";
    }
    description
      "none";
  }

  grouping ncs_rpc_notif_legacy-properties {
    leaf perceived-severity {
      type ncs_rpc_notif_perceived-severity;
      description
        "A device will provide an indication of importance for each alarm.
         This property indicates the importance.
         In some cases, the severity may change through the life of an active alarm.";
    }
    leaf service-affect {
      type ncs_rpc_notif_service-affect;
      description
        "Some devices will indicate, from its very narrow viewpoint, whether service has been impacted or not.
         This property carries this detail.";
    }
    leaf is-acknowledged {
      type boolean;
      description
        "Devices offer a capability to acknowledge alarms (to stop the bells ringing).
         Often an EMS will offer a similar capability.
         This property reflects the current acknowledge state.";
    }
    leaf-list additional-alarm-info {
      type string;
      description
        "Often, alarms raised by devices have additional information.
         This property can be used to convey this.";
    }
    description
      "At this point in the evolution of control solutions LegacyProperties are probably mandatory, however, it is anticipated that as control solutions advance the LegacyProperties will become irrelevant.";
  }

  grouping ncs_rpc_notif_approx-date-and-time {
    leaf primary-time-stamp {
      type tapi-common:ncs_rpc_notif_date-and-time;
      config false;
      description
        "Time of the event at the origin where known precisely.
         Where the event is known to be before particular time, this field records that time.
         Where the event is known to be after a particular time, this field records that time (this is an unusual case where there is no proposed before time).
         Where the event is known to have occurred in a time window, this field records the end time (the time before which the event must have occurred).";
    }
    leaf start-time-stamp {
      type tapi-common:ncs_rpc_notif_date-and-time;
      config false;
      description
        "The time after which the event is known to have occurred when the event is known to have occurred between two times.
         The primaryTimeStamp provides the end time.";
    }
    leaf spread {
      type ncs_rpc_notif_spread;
      config false;
      description
        "Indicates the knowledge of the time of occurrence of the event.";
    }
    leaf source-precision {
      type ncs_rpc_notif_source-precision;
      config false;
      description
        "Indicates how well the source time is synchronized with network time.";
    }
    description
      "Allows for recording of an aspect of imprecise time.";
  }

  grouping ncs_rpc_notif_compacted-log-details {
    leaf tombstone-retention {
      type string;
      config false;
      description
        "Time in minutes.
         The time period for which a Tombstone record will be held in the log from when it was logged.
         This provides an adjustment to the essential Compaction strategy such that after the tombstoneRetention period there will be no records about a particular thing that existed but no longer exists.
         Tombstone retention overrides recordRetention for Tombstones.
         Key word 'FOREVER' means that Tombstone records will never be removed from the log.
         Can be adjusted by an administrator (via a separate view) through the life of the stream.";
    }
    leaf compaction-delay {
      type string;
      config false;
      description
        "Time in minutes.
         The delay between logging the record and making the record available for compaction.
         This provides an adjustment to the essential Compaction strategy such that there may be several distinct records for the same thing in the where those records are not older than the Compaction Delay.
         Can be adjusted by an administrator (via a separate view) through the life of the stream.";
    }
    description
      "Details relevant for a CompactedLog.
       The essential Compacted Log strategy is to remove historic records about a particular thing such that only the latest record about each thing exists in the log.
       The essential strategy is refined by the parameters of this structure.";
  }

  grouping ncs_rpc_notif_alarm-condition-detector-detail {
    leaf alarm-detector-state {
      type ncs_rpc_notif_alarm-detector-state;
      config false;
      description
        "The state of the detector.
         The detector state accounts for the time characteristics of the detected condition.";
    }
    container legacy-properties {
      config false;
      uses ncs_rpc_notif_legacy-properties;
      description
        "Alarm systems of the 20th century were based primarily on local lamps (initially filament bulbs) and bells.
         Lamps can only be on or off, and bells sounding or not sounding, so alarms were Boolean in nature.
         Where a detector was essentially multi-state it was converted into multiple Boolean statements.
         The management of the equipments was essentially human only and local only (there were rarely remote systems).
         The device with the problem was the only possible indicator of importance and it had only three distinct bulbs to illuminate (filament bulbs tend to fail requiring costly replacement).
         The devices were relatively simple in function and analysis of the detectors was crude.
         There was only the device to indicate severity
         The device also could provide the best view as to whether a service was impacted, although clearly it had almost no knowledge.
         In a modern solution with well-connected remote systems that increasingly analyze problems and where there is increasingly 'lights out' building operation, the device's guess at severity etc. is irrelevant.
         In addition, with sophisticated resilience mechanisms, the device cannot make any relevant statement on whether the customer service has been impacted.
         Likewise, in a world where there were no remote systems and local management was the only practice, alarms had to be locally 'acknowledged'.
         Where there are remote systems, per alarm acknowledge is burdensome.
         However, many solutions and operational practices continue to use the historic schemes.
         On that basis, the schemes are supported but relegated to optional.";
    }
    description
      "A record of the state of a detector where that detector has two underling states that are of asymmetric importance.";
  }

  grouping ncs_rpc_notif_condition-detector {
    leaf condition-native-name {
      type string;
      config false;
      description
        "The name used for the Condition by the source of the information.";
    }
    leaf measured-entity-uuid {
      type tapi-common:ncs_rpc_notif_uuid;
      config false;
      description
        "The uuid of the TAPI entity that represents the entity measured at source.
         If the TAPI entity cannot be identified as it cannot be mapped, then this property can be omitted.
         If the TAPI entity is a local class, then this is the UUID of the GlobalClass parent of the entity of which this is part.";
    }
    leaf measured-entity-native-id {
      type string;
      config false;
      description
        "The identifier (invariant over the life) of the instance of the measured entity at the source.";
    }
    leaf condition-normalized-name {
      type string;
      config false;
      description
        "It is often the case that there is a Condition Name that is commonly used or even standardized that has not been used by the source of the condition.
         If this is the case, then that common/standard name is provided in via this property.";
    }
    leaf measured-entity-class {
      type ncs_rpc_notif_object-class-identifier;
      config false;
      description
        "The TAPI class of the measured entity.
         If the class cannot be identified as it cannot be mapped, then this property can be omitted.";
    }
    leaf detector-uuid {
      type tapi-common:ncs_rpc_notif_uuid;
      config false;
      description
        "The uuid of the TAPI entity that represents the detector.
         If the TAPI entity cannot be identified as it cannot be mapped, then this property can be omitted.
         Where the detector is not modelled independently, but instead is a part of the measured entity such that it is identified by a 'local id' built from the UUID of the measured entity and the condition name, then this property may be omitted.";
    }
    leaf detector-native-id {
      type string;
      config false;
      description
        "The identifier (invariant over the life) of the instance of the detector at the source (e.g. a device).
         The string reported in this field must include the:
         - device identifier
         - one or more resource identifiers including that of the measured entity
         It need not include the condition name.
        ";
    }
    leaf condition-detector-type {
      type ncs_rpc_notif_condition-detector-type;
      config false;
      description
        "Identifies the type of detector.
         This drives the conditional augmentation.
         Some types of detector may not need specific augmentation.
        ";
    }
    leaf-list measured-entity-local-id {
      type string;
      config false;
      description
        "Where the measured entity is a local class and hence does not have a UUID the local ID is provided in conjunction with the parents ID.
         The parent may also be a local class in which case its ID is a a local ID along with its parent ID.
         There will be a parent which is a global class which then supplies a UUID.
         The ID of the entity that is being measured is the combination of the UUID and the ordered list of local IDs.
         The local ID may not be provided where:
         - the report about a global class
         - the report is relying on the detectorNativeId.";
    }
    description
      "ConditionDetector represents any monitoring component that assesses properties of something and determines from those properties what conditions are associated with the thing.
       For example, a thing might be 'too hot' or might be 'unreliable'.
       The monitor may a multi-state output.
       The ConditionDetector lifecycle depends upon the lifecycle of the thing it is monitoring (this is a general OAM model consideration).
       The entityKey in the AppendLogRecordHeader for a ConditionDetector record is the nativeDetector Id which may be derived from other ids (most robustly, nativeOwningEntityName (to which the detector is associated) + natveConditionName).";
  }

  grouping ncs_rpc_notif_any-class {
    description
      "In the final version all classes that can stream will be explicitly associated with the AppendLogRecordBody";
  }

  grouping ncs_rpc_notif_stream-admin-context {
    list stream-monitor {
      key "uuid";
      config false;
      uses ncs_rpc_notif_stream-monitor;
      description
        "The list of available stream monitors.";
    }
    uses tapi-common:ncs_rpc_notif_global-class;
    description
      "Context providing access to stream administration functionality.";
  }

  grouping ncs_rpc_notif_stream-monitor {
    leaf id-of-last-record-read-from-log {
      type string;
      config false;
      description
        "The id/key of the last record read from the log by the client stream.
         The analysis of this value needs to account for stream buffering in the comms layer.";
    }
    leaf id-of-last-record-written-to-log {
      type string;
      config false;
      description
        "The id/key of the last record written to the log.
         This is the same value for all clients of the stream.";
    }
    container available-stream {
      uses ncs_rpc_notif_available-stream-ref;
      config false;
      description
        "none";
    }
    leaf client-id {
      type string;
      config false;
      description
        "The id of the connected client.";
    }
    leaf last-updated {
      type tapi-common:ncs_rpc_notif_date-and-time;
      config false;
      description
        "The date/time when the values provided were recorded.";
    }
    leaf client-address {
      type string;
      config false;
      description
        "The address of the connected client that is being monitored.";
    }
    uses tapi-common:ncs_rpc_notif_global-class;
    description
      "Information on the monitoring of the use of a specific AvailableStream.";
  }

  grouping ncs_rpc_notif_connection-protocol-details {
    leaf-list allowed-connection-protocols {
      type string;
      config false;
      description
        "Name of the allowed protocol.";
    }
    description
      "Details of the connection protocols available for the specific stream.";
  }

  grouping ncs_rpc_notif_available-stream {
    leaf connection-address {
      type string;
      config false;
      description
        "Provides the address for the connection.
         The format of the address and attachment mechanism will depend on the connection protocol defined in another attribute of this class.";
    }
    leaf stream-state {
      type ncs_rpc_notif_stream-state;
      config false;
      description
        "The state of the stream.";
    }
    container supported-stream-type {
      uses ncs_rpc_notif_supported-stream-type-ref;
      config false;
      description
        "Identifies the type of stream that is available for connection.";
    }
    leaf stream-id {
      type string;
      config false;
      description
        "The id of the stream.";
    }
    leaf connection-protocol {
      type string;
      config false;
      description
        "Names the connection protocol for this particular available stream.
         The connection protocol is chosen from the list of connection protocols identified in the referenced SupportedStreamType.";
    }
    uses tapi-common:ncs_rpc_notif_global-class;
    description
      "Details of stream a stream that can be connected to by a client application.";
  }

  grouping ncs_rpc_notif_stream-context {
    list available-stream {
      key "uuid";
      config false;
      uses ncs_rpc_notif_available-stream;
      description
        "none";
    }
    list supported-stream-type {
      key "uuid";
      config false;
      uses ncs_rpc_notif_supported-stream-type;
      description
        "none";
    }
    description
      "All streams relevant to the specific TapiContext.";
  }

  grouping ncs_rpc_notif_supported-stream-type {
    leaf stream-type-name {
      type string;
      config false;
      description
        "Name of the stream type.";
    }
    leaf record-retention {
      type string;
      config false;
      description
        "Time in minutes.
         Statement of retention time and/or retention capacity in bytes.
         Key word 'FOREVER' means that records will never be removed from the log.
         May be overridden for particular cases of specific LogStorageStrategy (via augment).";
    }
    leaf segment-size {
      type string;
      config false;
      description
        "Size of sub-structuring of the log.";
    }
    leaf-list record-content {
      type ncs_rpc_notif_object-class-identifier;
      description
        "Identifies the classes that are supported through the stream.
         The list may be a subset of the classes within the context.";
    }
    leaf log-storage-strategy {
      type ncs_rpc_notif_log-storage-strategy;
      config false;
      description
        "Indicates the storage characteristics of the log supporting the stream.";
    }
    leaf log-record-strategy {
      type ncs_rpc_notif_log-record-strategy;
      config false;
      description
        "Indicates the type of content of each log record.";
    }
    uses tapi-common:ncs_rpc_notif_global-class;
    description
      "Definition of a supported stream type.";
  }

  grouping ncs_rpc_notif_log-record {
    container log-record-header {
      config false;
      uses ncs_rpc_notif_log-record-header;
      description
        "The header of the log record providing general parameters of the record common to all records.";
    }
    container log-record-body {
      config false;
      uses ncs_rpc_notif_log-record-body;
      description
        "The body of the log record providing specific logged details.";
    }
    description
      "A specific atomic entry in a log.";
  }

  grouping ncs_rpc_notif_log-record-body {
    container event-time-stamp {
      config false;
      uses ncs_rpc_notif_approx-date-and-time;
      description
        "Time of the event at the origin of the event that triggered the generation of the record.
         The structure allows for time uncertainty.";
    }
    leaf event-source {
      type ncs_rpc_notif_event-source;
      config false;
      description
        "Indicates whether the source is controlled (under management control) or potentially chaotic (under resource control).
         The time characteristic of the source may be determined from the metadata describing the resource (e.g., a detector).
         Where there is an alternative (and probably more detailed) source of information on time characteristic this attribute can be omitted.";
    }
    list additional-event-info {
      key "value-name";
      config false;
      uses tapi-common:ncs_rpc_notif_name-and-value;
      description
        "Addition information related to the event such as change reason where changeReason would be the name and the value text would provide information on the reason for change.";
    }
    leaf-list parent-address {
      type string;
      config false;
      description
        "Where the entity is a local class this provides the ordered list of ids from the closest global class (a UUID cast as a string) to the direct parent (which may be the global class).
         The field can include all entities back to the Context and hence can be used for global classes where the tree is being represented in full.
         Gives the position of the entity in the address tree (usually containment) that is raising the event by providing the name/id values in the address of the parent.
         Is the sequence of named levels in the tree up to but excluding the entity of the notification.
         It includes the device id where relevant.";
    }
    leaf record-content {
      type ncs_rpc_notif_object-class-identifier;
      config false;
      description
        "The identifier of the object class in the record body detail.
         This property is used to control the conditional augmentation of the body with detail.";
    }
    description
      "The specific details of the Record.";
  }

  grouping ncs_rpc_notif_log-record-header {
    leaf tapi-context {
      type tapi-common:ncs_rpc_notif_uuid;
      config false;
      description
        "The identifier of the context.";
    }
    leaf token {
      type string;
      config false;
      description
        "A coded (and compact) form of the fullLogRecordOffsetId.
         This property is used to request streaming from a particular point (e.g., the last correctly handled record).";
    }
    list full-log-record-offset-id {
      key "value-name";
      config false;
      min-elements 1;
      uses tapi-common:ncs_rpc_notif_name-and-value;
      description
        "In a complex log solution there may be various parts to the log.
         The record token is a compressed form of log record reference.
         This property provides the verbose form
         For example, it may include:
         - stream id
         - topic
         - partition
         - partition offset
         - sequence number (the offset is essentially the sequence number associated with the partition)";
    }
    leaf log-append-time-stamp {
      type tapi-common:ncs_rpc_notif_date-and-time;
      config false;
      description
        "The time when the record was appended to the log.";
    }
    leaf entity-key {
      type string;
      config false;
      description
        "The identifier of the entity that is used in a Compacted log as the compaction key.
         The entityKey value, where appropriate, may be based upon the identifiers from the event source.
         It can be built from some specific detail combination that meets the necessary uniqueness and durability requirements.
         entityKey is the value used during compaction.
         Ideally it is a UUID format, if this can be formed from the source identifier.";
    }
    leaf record-type {
      type ncs_rpc_notif_record-type;
      config false;
      description
        "The type of the record.
         Can be used to understand which elements of the record will be present.";
    }
    leaf record-authenticity-token {
      type string;
      config false;
      description
        "none";
    }
    description
      "The header of the log record providing general parameters of the record common to all records.";
  }

  grouping ncs_rpc_notif_stream-record {
    list log-record {
      config false;
      uses ncs_rpc_notif_log-record;
      description
        "Each stream record may include a number of log records.";
    }
    description
      "The stream content.";
  }

  grouping live_ncs_available-stream-ref {
    leaf available-stream-uuid {
      type leafref {
        path "/ncs:devices/ncs:device/ncs:live-status/tapi-common:context/tapi-streaming:stream-context/tapi-streaming:available-stream/tapi-streaming:uuid" {
          tailf:xpath-root 3;
        }
      }
      description
        "none";
    }
    description
      "none";
  }

  grouping live_ncs_supported-stream-type-ref {
    leaf supported-stream-type-uuid {
      type leafref {
        path "/ncs:devices/ncs:device/ncs:live-status/tapi-common:context/tapi-streaming:stream-context/tapi-streaming:supported-stream-type/tapi-streaming:uuid" {
          tailf:xpath-root 3;
        }
      }
      description
        "none";
    }
    description
      "none";
  }

  grouping live_ncs_legacy-properties {
    leaf perceived-severity {
      type live_ncs_perceived-severity;
      description
        "A device will provide an indication of importance for each alarm.
         This property indicates the importance.
         In some cases, the severity may change through the life of an active alarm.";
    }
    leaf service-affect {
      type live_ncs_service-affect;
      description
        "Some devices will indicate, from its very narrow viewpoint, whether service has been impacted or not.
         This property carries this detail.";
    }
    leaf is-acknowledged {
      type boolean;
      description
        "Devices offer a capability to acknowledge alarms (to stop the bells ringing).
         Often an EMS will offer a similar capability.
         This property reflects the current acknowledge state.";
    }
    leaf-list additional-alarm-info {
      type string;
      description
        "Often, alarms raised by devices have additional information.
         This property can be used to convey this.";
    }
    description
      "At this point in the evolution of control solutions LegacyProperties are probably mandatory, however, it is anticipated that as control solutions advance the LegacyProperties will become irrelevant.";
  }

  grouping live_ncs_approx-date-and-time {
    leaf primary-time-stamp {
      type tapi-common:live_ncs_date-and-time;
      description
        "Time of the event at the origin where known precisely.
         Where the event is known to be before particular time, this field records that time.
         Where the event is known to be after a particular time, this field records that time (this is an unusual case where there is no proposed before time).
         Where the event is known to have occurred in a time window, this field records the end time (the time before which the event must have occurred).";
    }
    leaf start-time-stamp {
      type tapi-common:live_ncs_date-and-time;
      description
        "The time after which the event is known to have occurred when the event is known to have occurred between two times.
         The primaryTimeStamp provides the end time.";
    }
    leaf spread {
      type live_ncs_spread;
      description
        "Indicates the knowledge of the time of occurrence of the event.";
    }
    leaf source-precision {
      type live_ncs_source-precision;
      description
        "Indicates how well the source time is synchronized with network time.";
    }
    description
      "Allows for recording of an aspect of imprecise time.";
  }

  grouping live_ncs_compacted-log-details {
    leaf tombstone-retention {
      type string;
      description
        "Time in minutes.
         The time period for which a Tombstone record will be held in the log from when it was logged.
         This provides an adjustment to the essential Compaction strategy such that after the tombstoneRetention period there will be no records about a particular thing that existed but no longer exists.
         Tombstone retention overrides recordRetention for Tombstones.
         Key word 'FOREVER' means that Tombstone records will never be removed from the log.
         Can be adjusted by an administrator (via a separate view) through the life of the stream.";
    }
    leaf compaction-delay {
      type string;
      description
        "Time in minutes.
         The delay between logging the record and making the record available for compaction.
         This provides an adjustment to the essential Compaction strategy such that there may be several distinct records for the same thing in the where those records are not older than the Compaction Delay.
         Can be adjusted by an administrator (via a separate view) through the life of the stream.";
    }
    description
      "Details relevant for a CompactedLog.
       The essential Compacted Log strategy is to remove historic records about a particular thing such that only the latest record about each thing exists in the log.
       The essential strategy is refined by the parameters of this structure.";
  }

  grouping live_ncs_alarm-condition-detector-detail {
    leaf alarm-detector-state {
      type live_ncs_alarm-detector-state;
      description
        "The state of the detector.
         The detector state accounts for the time characteristics of the detected condition.";
    }
    container legacy-properties {
      uses live_ncs_legacy-properties;
      description
        "Alarm systems of the 20th century were based primarily on local lamps (initially filament bulbs) and bells.
         Lamps can only be on or off, and bells sounding or not sounding, so alarms were Boolean in nature.
         Where a detector was essentially multi-state it was converted into multiple Boolean statements.
         The management of the equipments was essentially human only and local only (there were rarely remote systems).
         The device with the problem was the only possible indicator of importance and it had only three distinct bulbs to illuminate (filament bulbs tend to fail requiring costly replacement).
         The devices were relatively simple in function and analysis of the detectors was crude.
         There was only the device to indicate severity
         The device also could provide the best view as to whether a service was impacted, although clearly it had almost no knowledge.
         In a modern solution with well-connected remote systems that increasingly analyze problems and where there is increasingly 'lights out' building operation, the device's guess at severity etc. is irrelevant.
         In addition, with sophisticated resilience mechanisms, the device cannot make any relevant statement on whether the customer service has been impacted.
         Likewise, in a world where there were no remote systems and local management was the only practice, alarms had to be locally 'acknowledged'.
         Where there are remote systems, per alarm acknowledge is burdensome.
         However, many solutions and operational practices continue to use the historic schemes.
         On that basis, the schemes are supported but relegated to optional.";
    }
    description
      "A record of the state of a detector where that detector has two underling states that are of asymmetric importance.";
  }

  grouping live_ncs_condition-detector {
    leaf condition-native-name {
      type string;
      description
        "The name used for the Condition by the source of the information.";
    }
    leaf measured-entity-uuid {
      type tapi-common:live_ncs_uuid;
      description
        "The uuid of the TAPI entity that represents the entity measured at source.
         If the TAPI entity cannot be identified as it cannot be mapped, then this property can be omitted.
         If the TAPI entity is a local class, then this is the UUID of the GlobalClass parent of the entity of which this is part.";
    }
    leaf measured-entity-native-id {
      type string;
      description
        "The identifier (invariant over the life) of the instance of the measured entity at the source.";
    }
    leaf condition-normalized-name {
      type string;
      description
        "It is often the case that there is a Condition Name that is commonly used or even standardized that has not been used by the source of the condition.
         If this is the case, then that common/standard name is provided in via this property.";
    }
    leaf measured-entity-class {
      type live_ncs_object-class-identifier;
      description
        "The TAPI class of the measured entity.
         If the class cannot be identified as it cannot be mapped, then this property can be omitted.";
    }
    leaf detector-uuid {
      type tapi-common:live_ncs_uuid;
      description
        "The uuid of the TAPI entity that represents the detector.
         If the TAPI entity cannot be identified as it cannot be mapped, then this property can be omitted.
         Where the detector is not modelled independently, but instead is a part of the measured entity such that it is identified by a 'local id' built from the UUID of the measured entity and the condition name, then this property may be omitted.";
    }
    leaf detector-native-id {
      type string;
      description
        "The identifier (invariant over the life) of the instance of the detector at the source (e.g. a device).
         The string reported in this field must include the:
         - device identifier
         - one or more resource identifiers including that of the measured entity
         It need not include the condition name.
        ";
    }
    leaf condition-detector-type {
      type live_ncs_condition-detector-type;
      description
        "Identifies the type of detector.
         This drives the conditional augmentation.
         Some types of detector may not need specific augmentation.
        ";
    }
    leaf-list measured-entity-local-id {
      type string;
      description
        "Where the measured entity is a local class and hence does not have a UUID the local ID is provided in conjunction with the parents ID.
         The parent may also be a local class in which case its ID is a a local ID along with its parent ID.
         There will be a parent which is a global class which then supplies a UUID.
         The ID of the entity that is being measured is the combination of the UUID and the ordered list of local IDs.
         The local ID may not be provided where:
         - the report about a global class
         - the report is relying on the detectorNativeId.";
    }
    description
      "ConditionDetector represents any monitoring component that assesses properties of something and determines from those properties what conditions are associated with the thing.
       For example, a thing might be 'too hot' or might be 'unreliable'.
       The monitor may a multi-state output.
       The ConditionDetector lifecycle depends upon the lifecycle of the thing it is monitoring (this is a general OAM model consideration).
       The entityKey in the AppendLogRecordHeader for a ConditionDetector record is the nativeDetector Id which may be derived from other ids (most robustly, nativeOwningEntityName (to which the detector is associated) + natveConditionName).";
  }

  grouping live_ncs_any-class {
    description
      "In the final version all classes that can stream will be explicitly associated with the AppendLogRecordBody";
  }

  grouping live_ncs_stream-admin-context {
    list stream-monitor {
      key "uuid";
      uses live_ncs_stream-monitor;
      description
        "The list of available stream monitors.";
    }
    uses tapi-common:live_ncs_global-class;
    description
      "Context providing access to stream administration functionality.";
  }

  grouping live_ncs_stream-monitor {
    leaf id-of-last-record-read-from-log {
      type string;
      description
        "The id/key of the last record read from the log by the client stream.
         The analysis of this value needs to account for stream buffering in the comms layer.";
    }
    leaf id-of-last-record-written-to-log {
      type string;
      description
        "The id/key of the last record written to the log.
         This is the same value for all clients of the stream.";
    }
    container available-stream {
      uses live_ncs_available-stream-ref;
      description
        "none";
    }
    leaf client-id {
      type string;
      description
        "The id of the connected client.";
    }
    leaf last-updated {
      type tapi-common:live_ncs_date-and-time;
      description
        "The date/time when the values provided were recorded.";
    }
    leaf client-address {
      type string;
      description
        "The address of the connected client that is being monitored.";
    }
    uses tapi-common:live_ncs_global-class;
    description
      "Information on the monitoring of the use of a specific AvailableStream.";
  }

  grouping live_ncs_connection-protocol-details {
    leaf-list allowed-connection-protocols {
      type string;
      description
        "Name of the allowed protocol.";
    }
    description
      "Details of the connection protocols available for the specific stream.";
  }

  grouping live_ncs_available-stream {
    leaf connection-address {
      type string;
      description
        "Provides the address for the connection.
         The format of the address and attachment mechanism will depend on the connection protocol defined in another attribute of this class.";
    }
    leaf stream-state {
      type live_ncs_stream-state;
      description
        "The state of the stream.";
    }
    container supported-stream-type {
      uses live_ncs_supported-stream-type-ref;
      description
        "Identifies the type of stream that is available for connection.";
    }
    leaf stream-id {
      type string;
      description
        "The id of the stream.";
    }
    leaf connection-protocol {
      type string;
      description
        "Names the connection protocol for this particular available stream.
         The connection protocol is chosen from the list of connection protocols identified in the referenced SupportedStreamType.";
    }
    uses tapi-common:live_ncs_global-class;
    description
      "Details of stream a stream that can be connected to by a client application.";
  }

  grouping live_ncs_stream-context {
    list available-stream {
      key "uuid";
      uses live_ncs_available-stream;
      description
        "none";
    }
    list supported-stream-type {
      key "uuid";
      uses live_ncs_supported-stream-type;
      description
        "none";
    }
    description
      "All streams relevant to the specific TapiContext.";
  }

  grouping live_ncs_supported-stream-type {
    leaf stream-type-name {
      type string;
      description
        "Name of the stream type.";
    }
    leaf record-retention {
      type string;
      description
        "Time in minutes.
         Statement of retention time and/or retention capacity in bytes.
         Key word 'FOREVER' means that records will never be removed from the log.
         May be overridden for particular cases of specific LogStorageStrategy (via augment).";
    }
    leaf segment-size {
      type string;
      description
        "Size of sub-structuring of the log.";
    }
    leaf-list record-content {
      type live_ncs_object-class-identifier;
      description
        "Identifies the classes that are supported through the stream.
         The list may be a subset of the classes within the context.";
    }
    leaf log-storage-strategy {
      type live_ncs_log-storage-strategy;
      description
        "Indicates the storage characteristics of the log supporting the stream.";
    }
    leaf log-record-strategy {
      type live_ncs_log-record-strategy;
      description
        "Indicates the type of content of each log record.";
    }
    uses tapi-common:live_ncs_global-class;
    description
      "Definition of a supported stream type.";
  }

  grouping live_ncs_log-record {
    container log-record-header {
      uses live_ncs_log-record-header;
      description
        "The header of the log record providing general parameters of the record common to all records.";
    }
    container log-record-body {
      uses live_ncs_log-record-body;
      description
        "The body of the log record providing specific logged details.";
    }
    description
      "A specific atomic entry in a log.";
  }

  grouping live_ncs_log-record-body {
    container event-time-stamp {
      uses live_ncs_approx-date-and-time;
      description
        "Time of the event at the origin of the event that triggered the generation of the record.
         The structure allows for time uncertainty.";
    }
    leaf event-source {
      type live_ncs_event-source;
      description
        "Indicates whether the source is controlled (under management control) or potentially chaotic (under resource control).
         The time characteristic of the source may be determined from the metadata describing the resource (e.g., a detector).
         Where there is an alternative (and probably more detailed) source of information on time characteristic this attribute can be omitted.";
    }
    list additional-event-info {
      key "value-name";
      uses tapi-common:live_ncs_name-and-value;
      description
        "Addition information related to the event such as change reason where changeReason would be the name and the value text would provide information on the reason for change.";
    }
    leaf-list parent-address {
      type string;
      description
        "Where the entity is a local class this provides the ordered list of ids from the closest global class (a UUID cast as a string) to the direct parent (which may be the global class).
         The field can include all entities back to the Context and hence can be used for global classes where the tree is being represented in full.
         Gives the position of the entity in the address tree (usually containment) that is raising the event by providing the name/id values in the address of the parent.
         Is the sequence of named levels in the tree up to but excluding the entity of the notification.
         It includes the device id where relevant.";
    }
    leaf record-content {
      type live_ncs_object-class-identifier;
      description
        "The identifier of the object class in the record body detail.
         This property is used to control the conditional augmentation of the body with detail.";
    }
    description
      "The specific details of the Record.";
  }

  grouping live_ncs_log-record-header {
    leaf tapi-context {
      type tapi-common:live_ncs_uuid;
      description
        "The identifier of the context.";
    }
    leaf token {
      type string;
      description
        "A coded (and compact) form of the fullLogRecordOffsetId.
         This property is used to request streaming from a particular point (e.g., the last correctly handled record).";
    }
    list full-log-record-offset-id {
      key "value-name";
      // NCS drop min-elements statement
      uses tapi-common:live_ncs_name-and-value;
      description
        "In a complex log solution there may be various parts to the log.
         The record token is a compressed form of log record reference.
         This property provides the verbose form
         For example, it may include:
         - stream id
         - topic
         - partition
         - partition offset
         - sequence number (the offset is essentially the sequence number associated with the partition)";
    }
    leaf log-append-time-stamp {
      type tapi-common:live_ncs_date-and-time;
      description
        "The time when the record was appended to the log.";
    }
    leaf entity-key {
      type string;
      description
        "The identifier of the entity that is used in a Compacted log as the compaction key.
         The entityKey value, where appropriate, may be based upon the identifiers from the event source.
         It can be built from some specific detail combination that meets the necessary uniqueness and durability requirements.
         entityKey is the value used during compaction.
         Ideally it is a UUID format, if this can be formed from the source identifier.";
    }
    leaf record-type {
      type live_ncs_record-type;
      description
        "The type of the record.
         Can be used to understand which elements of the record will be present.";
    }
    leaf record-authenticity-token {
      type string;
      description
        "none";
    }
    description
      "The header of the log record providing general parameters of the record common to all records.";
  }

  grouping live_ncs_stream-record {
    list log-record {
      uses live_ncs_log-record;
      description
        "Each stream record may include a number of log records.";
    }
    description
      "The stream content.";
  }

  grouping available-stream-ref {
    leaf available-stream-uuid {
      type leafref {
        path "/ncs:devices/ncs:device/ncs:live-status/tapi-common:context/tapi-streaming:stream-context/tapi-streaming:available-stream/tapi-streaming:uuid" {
          tailf:xpath-root 2;
        }
      }
      description
        "none";
    }
    description
      "none";
  }

  grouping supported-stream-type-ref {
    leaf supported-stream-type-uuid {
      type leafref {
        path "/ncs:devices/ncs:device/ncs:live-status/tapi-common:context/tapi-streaming:stream-context/tapi-streaming:supported-stream-type/tapi-streaming:uuid" {
          tailf:xpath-root 2;
        }
      }
      description
        "none";
    }
    description
      "none";
  }

  grouping legacy-properties {
    leaf perceived-severity {
      type perceived-severity;
      description
        "A device will provide an indication of importance for each alarm.
         This property indicates the importance.
         In some cases, the severity may change through the life of an active alarm.";
    }
    leaf service-affect {
      type service-affect;
      description
        "Some devices will indicate, from its very narrow viewpoint, whether service has been impacted or not.
         This property carries this detail.";
    }
    leaf is-acknowledged {
      type boolean;
      description
        "Devices offer a capability to acknowledge alarms (to stop the bells ringing).
         Often an EMS will offer a similar capability.
         This property reflects the current acknowledge state.";
    }
    leaf-list additional-alarm-info {
      type string;
      description
        "Often, alarms raised by devices have additional information.
         This property can be used to convey this.";
    }
    description
      "At this point in the evolution of control solutions LegacyProperties are probably mandatory, however, it is anticipated that as control solutions advance the LegacyProperties will become irrelevant.";
  }

  grouping approx-date-and-time {
    // NCS drop config false leaf 'primary-time-stamp'
    // NCS drop config false leaf 'start-time-stamp'
    // NCS drop config false leaf spread
    // NCS drop config false leaf 'source-precision'
    description
      "Allows for recording of an aspect of imprecise time.";
  }

  grouping compacted-log-details {
    // NCS drop config false leaf 'tombstone-retention'
    // NCS drop config false leaf 'compaction-delay'
    description
      "Details relevant for a CompactedLog.
       The essential Compacted Log strategy is to remove historic records about a particular thing such that only the latest record about each thing exists in the log.
       The essential strategy is refined by the parameters of this structure.";
  }

  grouping alarm-condition-detector-detail {
    // NCS drop config false leaf 'alarm-detector-state'
    // NCS drop config false container 'legacy-properties'
    description
      "A record of the state of a detector where that detector has two underling states that are of asymmetric importance.";
  }

  grouping condition-detector {
    // NCS drop config false leaf 'condition-native-name'
    // NCS drop config false leaf 'measured-entity-uuid'
    // NCS drop config false leaf 'measured-entity-native-id'
    // NCS drop config false leaf 'condition-normalized-name'
    // NCS drop config false leaf 'measured-entity-class'
    // NCS drop config false leaf 'detector-uuid'
    // NCS drop config false leaf 'detector-native-id'
    // NCS drop config false leaf 'condition-detector-type'
    // NCS drop config false leaf-list 'measured-entity-local-id'
    description
      "ConditionDetector represents any monitoring component that assesses properties of something and determines from those properties what conditions are associated with the thing.
       For example, a thing might be 'too hot' or might be 'unreliable'.
       The monitor may a multi-state output.
       The ConditionDetector lifecycle depends upon the lifecycle of the thing it is monitoring (this is a general OAM model consideration).
       The entityKey in the AppendLogRecordHeader for a ConditionDetector record is the nativeDetector Id which may be derived from other ids (most robustly, nativeOwningEntityName (to which the detector is associated) + natveConditionName).";
  }

  grouping any-class {
    description
      "In the final version all classes that can stream will be explicitly associated with the AppendLogRecordBody";
  }

  grouping stream-admin-context {
    // NCS drop config false list 'stream-monitor'
    uses tapi-common:global-class;
    description
      "Context providing access to stream administration functionality.";
  }

  grouping stream-monitor {
    // NCS drop config false leaf 'id-of-last-record-read-from-log'
    // NCS drop config false leaf 'id-of-last-record-written-to-log'
    // NCS drop config false container 'available-stream'
    // NCS drop config false leaf 'client-id'
    // NCS drop config false leaf 'last-updated'
    // NCS drop config false leaf 'client-address'
    uses tapi-common:global-class;
    description
      "Information on the monitoring of the use of a specific AvailableStream.";
  }

  grouping connection-protocol-details {
    // NCS drop config false leaf-list 'allowed-connection-protocols'
    description
      "Details of the connection protocols available for the specific stream.";
  }

  grouping available-stream {
    // NCS drop config false leaf 'connection-address'
    // NCS drop config false leaf 'stream-state'
    // NCS drop config false container 'supported-stream-type'
    // NCS drop config false leaf 'stream-id'
    // NCS drop config false leaf 'connection-protocol'
    uses tapi-common:global-class;
    description
      "Details of stream a stream that can be connected to by a client application.";
  }

  grouping stream-context {
    // NCS drop config false list 'available-stream'
    // NCS drop config false list 'supported-stream-type'
    description
      "All streams relevant to the specific TapiContext.";
  }

  grouping supported-stream-type {
    // NCS drop config false leaf 'stream-type-name'
    // NCS drop config false leaf 'record-retention'
    // NCS drop config false leaf 'segment-size'
    leaf-list record-content {
      type object-class-identifier;
      description
        "Identifies the classes that are supported through the stream.
         The list may be a subset of the classes within the context.";
    }
    // NCS drop config false leaf 'log-storage-strategy'
    // NCS drop config false leaf 'log-record-strategy'
    uses tapi-common:global-class;
    description
      "Definition of a supported stream type.";
  }

  grouping log-record {
    // NCS drop config false container 'log-record-header'
    // NCS drop config false container 'log-record-body'
    description
      "A specific atomic entry in a log.";
  }

  grouping log-record-body {
    // NCS drop config false container 'event-time-stamp'
    // NCS drop config false leaf 'event-source'
    // NCS drop config false list 'additional-event-info'
    // NCS drop config false leaf-list 'parent-address'
    // NCS drop config false leaf 'record-content'
    description
      "The specific details of the Record.";
  }

  grouping log-record-header {
    // NCS drop config false leaf 'tapi-context'
    // NCS drop config false leaf token
    // NCS drop config false list 'full-log-record-offset-id'
    // NCS drop config false leaf 'log-append-time-stamp'
    // NCS drop config false leaf 'entity-key'
    // NCS drop config false leaf 'record-type'
    // NCS drop config false leaf 'record-authenticity-token'
    description
      "The header of the log record providing general parameters of the record common to all records.";
  }

  grouping stream-record {
    // NCS drop config false list 'log-record'
    description
      "The stream content.";
  }

  augment "/ncs:devices/ncs:device/ncs:rpc" {
    container rpc-get-supported-stream-connection-types {
      tailf:ncs-device-type "netconf";
      tailf:display-when "not(../../ncs:module) or ../../ncs:module[ncs:name='tapi-streaming']";
      tailf:action get-supported-stream-connection-types {
        tailf:actionpoint ncsproxy {
          tailf:internal;
        }
        description
          "none";
        output {
          list supported-stream-types {
            uses ncs_rpc_notif_supported-stream-type;
            description
              "none";
          }
        }
      }
    }
  }
  augment "/ncs:devices/ncs:device-group/ncs:ned-id/ncs:rpc" {
    container rpc-get-supported-stream-connection-types {
      tailf:ncs-device-type "netconf";
      tailf:display-when "../../ncs:id = 'onf-tapi-nc-2.0:onf-tapi-nc-2.0'";
      tailf:action get-supported-stream-connection-types {
        tailf:actionpoint ncsproxy {
          tailf:internal;
        }
        description
          "none";
        output {
          container "device" {
            leaf "name" {
              type string;
            }
            leaf "info" {
              type string;
            }
            container "result" {
              list supported-stream-types {
                uses ncs_rpc_notif_supported-stream-type;
                description
                  "none";
              }
            }
          }
        }
      }
    }
  }
  augment "/ncs:devices/ncs:device/ncs:rpc" {
    container rpc-get-available-stream-connection-details {
      tailf:ncs-device-type "netconf";
      tailf:display-when "not(../../ncs:module) or ../../ncs:module[ncs:name='tapi-streaming']";
      tailf:action get-available-stream-connection-details {
        tailf:actionpoint ncsproxy {
          tailf:internal;
        }
        description
          "none";
        output {
          list active-connections {
            uses ncs_rpc_notif_available-stream;
            description
              "none";
          }
        }
      }
    }
  }
  augment "/ncs:devices/ncs:device-group/ncs:ned-id/ncs:rpc" {
    container rpc-get-available-stream-connection-details {
      tailf:ncs-device-type "netconf";
      tailf:display-when "../../ncs:id = 'onf-tapi-nc-2.0:onf-tapi-nc-2.0'";
      tailf:action get-available-stream-connection-details {
        tailf:actionpoint ncsproxy {
          tailf:internal;
        }
        description
          "none";
        output {
          container "device" {
            leaf "name" {
              type string;
            }
            leaf "info" {
              type string;
            }
            container "result" {
              list active-connections {
                uses ncs_rpc_notif_available-stream;
                description
                  "none";
              }
            }
          }
        }
      }
    }
  }
  augment "/ncs:devices/ncs:device/ncs:rpc" {
    container rpc-connect-to-stream {
      tailf:ncs-device-type "netconf";
      tailf:display-when "not(../../ncs:module) or ../../ncs:module[ncs:name='tapi-streaming']";
      tailf:action connect-to-stream {
        tailf:actionpoint ncsproxy {
          tailf:internal;
        }
        description
          "none";
        input {
          leaf start-from-token {
            type string;
            description
              "none";
          }
          leaf connection-address {
            type string;
            description
              "none";
          }
        }
      }
    }
  }
  augment "/ncs:devices/ncs:device-group/ncs:ned-id/ncs:rpc" {
    container rpc-connect-to-stream {
      tailf:ncs-device-type "netconf";
      tailf:display-when "../../ncs:id = 'onf-tapi-nc-2.0:onf-tapi-nc-2.0'";
      tailf:action connect-to-stream {
        tailf:actionpoint ncsproxy {
          tailf:internal;
        }
        description
          "none";
        input {
          leaf start-from-token {
            type string;
            description
              "none";
          }
          leaf connection-address {
            type string;
            description
              "none";
          }
        }
      }
    }
  }
  augment "/ncs:devices/ncs:device/ncs:notifications/ncs:received-notifications/ncs:notification/ncs:data" {
    container stream-record {
      presence "";
      config false;
      uses ncs_rpc_notif_stream-record;
      description
        "none";
    }
  }
  augment "/ncs:devices/ncs:device/ncs:netconf-notifications/ncs:received-notifications/ncs:notification/ncs:data" {
    container stream-record {
      presence "";
      config false;
      uses ncs_rpc_notif_stream-record;
      description
        "none";
    }
  }
  augment "/ncs:devices/ncs:device/ncs:live-status/tapi-common:context/tapi-streaming:stream-context/tapi-streaming:supported-stream-type" {
    // NCS drop if-feature statement
    container compacted-log-details {
      tailf:ncs-device-type "netconf";
      tailf:display-when "not(../../../../../ncs:module) or ../../../../../ncs:module[ncs:name='tapi-streaming'] or (../../../../../ncs:live-status-protocol[not(ncs:capability)]) or (../../../../../ncs:live-status-protocol/ncs:capability/ncs:module[.='tapi-streaming'])";
      uses live_ncs_compacted-log-details;
      description
        "none";
    }
    description
      "none";
  }
  augment "/ncs:devices/ncs:device/ncs:notifications/ncs:received-notifications/ncs:notification/ncs:data/tapi-streaming:stream-record/tapi-streaming:log-record/tapi-streaming:log-record-body/tapi-streaming:condition-detector" {
    // NCS drop if-feature statement
    container alarm-condition-detector-detail {
      uses ncs_rpc_notif_alarm-condition-detector-detail;
      description
        "none";
    }
    description
      "none";
  }
  augment "/ncs:devices/ncs:device/ncs:netconf-notifications/ncs:received-notifications/ncs:notification/ncs:data/tapi-streaming:stream-record/tapi-streaming:log-record/tapi-streaming:log-record-body/tapi-streaming:condition-detector" {
    // NCS drop if-feature statement
    container alarm-condition-detector-detail {
      uses ncs_rpc_notif_alarm-condition-detector-detail;
      description
        "none";
    }
    description
      "none";
  }
  augment "/ncs:devices/ncs:device/ncs:notifications/ncs:received-notifications/ncs:notification/ncs:data/tapi-streaming:stream-record/tapi-streaming:log-record/tapi-streaming:log-record-body" {
    when "tapi-streaming:record-content='SERVICE_INTERFACE_POINT'" {
      tailf:xpath-root 6;
    }
    // NCS drop if-feature statement
    container service-interface-point {
      uses tapi-common:ncs_rpc_notif_service-interface-point;
      description
        "none";
    }
    description
      "none";
  }
  augment "/ncs:devices/ncs:device/ncs:netconf-notifications/ncs:received-notifications/ncs:notification/ncs:data/tapi-streaming:stream-record/tapi-streaming:log-record/tapi-streaming:log-record-body" {
    when "tapi-streaming:record-content='SERVICE_INTERFACE_POINT'" {
      tailf:xpath-root 6;
    }
    // NCS drop if-feature statement
    container service-interface-point {
      uses tapi-common:ncs_rpc_notif_service-interface-point;
      description
        "none";
    }
    description
      "none";
  }
  augment "/ncs:devices/ncs:device/ncs:notifications/ncs:received-notifications/ncs:notification/ncs:data/tapi-streaming:stream-record/tapi-streaming:log-record/tapi-streaming:log-record-body" {
    when "tapi-streaming:record-content='CONDITION_DETECTOR'" {
      tailf:xpath-root 6;
    }
    // NCS drop if-feature statement
    container condition-detector {
      uses ncs_rpc_notif_condition-detector;
      description
        "none";
    }
    description
      "none";
  }
  augment "/ncs:devices/ncs:device/ncs:netconf-notifications/ncs:received-notifications/ncs:notification/ncs:data/tapi-streaming:stream-record/tapi-streaming:log-record/tapi-streaming:log-record-body" {
    when "tapi-streaming:record-content='CONDITION_DETECTOR'" {
      tailf:xpath-root 6;
    }
    // NCS drop if-feature statement
    container condition-detector {
      uses ncs_rpc_notif_condition-detector;
      description
        "none";
    }
    description
      "none";
  }
  augment "/ncs:devices/ncs:device/ncs:notifications/ncs:received-notifications/ncs:notification/ncs:data/tapi-streaming:stream-record/tapi-streaming:log-record/tapi-streaming:log-record-body" {
    when "tapi-streaming:record-content='ANY_CLASS'" {
      tailf:xpath-root 6;
    }
    // NCS drop if-feature statement
    container any-class {
      uses ncs_rpc_notif_any-class;
      description
        "none";
    }
    description
      "none";
  }
  augment "/ncs:devices/ncs:device/ncs:netconf-notifications/ncs:received-notifications/ncs:notification/ncs:data/tapi-streaming:stream-record/tapi-streaming:log-record/tapi-streaming:log-record-body" {
    when "tapi-streaming:record-content='ANY_CLASS'" {
      tailf:xpath-root 6;
    }
    // NCS drop if-feature statement
    container any-class {
      uses ncs_rpc_notif_any-class;
      description
        "none";
    }
    description
      "none";
  }
  augment "/ncs:devices/ncs:template/ncs:ned-id/ncs:config/tapi-common:context" {
    // NCS drop if-feature statement
    container stream-admin-context {
      uses ncs_template_stream-admin-context;
      description
        "none";
    }
    description
      "none";
  }
  augment "/ncs:devices/ncs:device/ncs:live-status/tapi-common:context" {
    // NCS drop if-feature statement
    container stream-admin-context {
      tailf:ncs-device-type "netconf";
      tailf:display-when "not(../../../ncs:module) or ../../../ncs:module[ncs:name='tapi-streaming'] or (../../../ncs:live-status-protocol[not(ncs:capability)]) or (../../../ncs:live-status-protocol/ncs:capability/ncs:module[.='tapi-streaming'])";
      uses live_ncs_stream-admin-context;
      description
        "none";
    }
    description
      "none";
  }
  augment "/ncs:devices/ncs:device/ncs:config/tapi-common:context" {
    // NCS drop if-feature statement
    container stream-admin-context {
      tailf:ncs-device-type "netconf";
      tailf:display-when "not(../../../ncs:module) or ../../../ncs:module[ncs:name='tapi-streaming']";
      uses stream-admin-context;
      description
        "none";
    }
    description
      "none";
  }
  augment "/ncs:devices/ncs:template/ncs:ned-id/ncs:config/tapi-common:context" {
    // NCS drop if-feature statement
    container stream-context {
      uses ncs_template_stream-context;
      description
        "none";
    }
    description
      "none";
  }
  augment "/ncs:devices/ncs:device/ncs:live-status/tapi-common:context" {
    // NCS drop if-feature statement
    container stream-context {
      tailf:ncs-device-type "netconf";
      tailf:display-when "not(../../../ncs:module) or ../../../ncs:module[ncs:name='tapi-streaming'] or (../../../ncs:live-status-protocol[not(ncs:capability)]) or (../../../ncs:live-status-protocol/ncs:capability/ncs:module[.='tapi-streaming'])";
      uses live_ncs_stream-context;
      description
        "none";
    }
    description
      "none";
  }
  augment "/ncs:devices/ncs:device/ncs:config/tapi-common:context" {
    // NCS drop if-feature statement
    container stream-context {
      tailf:ncs-device-type "netconf";
      tailf:display-when "not(../../../ncs:module) or ../../../ncs:module[ncs:name='tapi-streaming']";
      uses stream-context;
      description
        "none";
    }
    description
      "none";
  }
  augment "/ncs:devices/ncs:device/ncs:live-status/tapi-common:context/tapi-streaming:stream-context/tapi-streaming:supported-stream-type" {
    // NCS drop if-feature statement
    container connection-protocol-details {
      tailf:ncs-device-type "netconf";
      tailf:display-when "not(../../../../../ncs:module) or ../../../../../ncs:module[ncs:name='tapi-streaming'] or (../../../../../ncs:live-status-protocol[not(ncs:capability)]) or (../../../../../ncs:live-status-protocol/ncs:capability/ncs:module[.='tapi-streaming'])";
      uses live_ncs_connection-protocol-details;
      description
        "none";
    }
    description
      "none";
  }
  augment "/ncs:devices/ncs:device/ncs:notifications/ncs:received-notifications/ncs:notification/ncs:data/tapi-streaming:stream-record/tapi-streaming:log-record/tapi-streaming:log-record-body" {
    when "tapi-streaming:record-content='STREAM_MONITOR'" {
      tailf:xpath-root 6;
    }
    // NCS drop if-feature statement
    container stream-monitor {
      uses ncs_rpc_notif_stream-monitor;
      description
        "none";
    }
    description
      "none";
  }
  augment "/ncs:devices/ncs:device/ncs:netconf-notifications/ncs:received-notifications/ncs:notification/ncs:data/tapi-streaming:stream-record/tapi-streaming:log-record/tapi-streaming:log-record-body" {
    when "tapi-streaming:record-content='STREAM_MONITOR'" {
      tailf:xpath-root 6;
    }
    // NCS drop if-feature statement
    container stream-monitor {
      uses ncs_rpc_notif_stream-monitor;
      description
        "none";
    }
    description
      "none";
  }
  augment "/ncs:devices/ncs:device/ncs:notifications/ncs:received-notifications/ncs:notification/ncs:data/tapi-streaming:stream-record/tapi-streaming:log-record/tapi-streaming:log-record-body" {
    when "tapi-streaming:record-content='SUPPORTED_STREAM_TYPE'" {
      tailf:xpath-root 6;
    }
    // NCS drop if-feature statement
    container supported-stream-type {
      uses ncs_rpc_notif_supported-stream-type;
      description
        "none";
    }
    description
      "none";
  }
  augment "/ncs:devices/ncs:device/ncs:netconf-notifications/ncs:received-notifications/ncs:notification/ncs:data/tapi-streaming:stream-record/tapi-streaming:log-record/tapi-streaming:log-record-body" {
    when "tapi-streaming:record-content='SUPPORTED_STREAM_TYPE'" {
      tailf:xpath-root 6;
    }
    // NCS drop if-feature statement
    container supported-stream-type {
      uses ncs_rpc_notif_supported-stream-type;
      description
        "none";
    }
    description
      "none";
  }
  augment "/ncs:devices/ncs:device/ncs:notifications/ncs:received-notifications/ncs:notification/ncs:data/tapi-streaming:stream-record/tapi-streaming:log-record/tapi-streaming:log-record-body" {
    when "tapi-streaming:record-content='AVAILABLE_STREAM_TYPE'" {
      tailf:xpath-root 6;
    }
    // NCS drop if-feature statement
    container available-stream {
      uses ncs_rpc_notif_available-stream;
      description
        "none";
    }
    description
      "none";
  }
  augment "/ncs:devices/ncs:device/ncs:netconf-notifications/ncs:received-notifications/ncs:notification/ncs:data/tapi-streaming:stream-record/tapi-streaming:log-record/tapi-streaming:log-record-body" {
    when "tapi-streaming:record-content='AVAILABLE_STREAM_TYPE'" {
      tailf:xpath-root 6;
    }
    // NCS drop if-feature statement
    container available-stream {
      uses ncs_rpc_notif_available-stream;
      description
        "none";
    }
    description
      "none";
  }
  augment "/ncs:devices/ncs:device/ncs:notifications/ncs:received-notifications/ncs:notification/ncs:data/tapi-streaming:stream-record/tapi-streaming:log-record/tapi-streaming:log-record-body" {
    when "tapi-streaming:record-content='CONNECTION'" {
      tailf:xpath-root 6;
    }
    // NCS drop if-feature statement
    container connection {
      uses tapi-connectivity:ncs_rpc_notif_connection;
      description
        "none";
    }
    description
      "none";
  }
  augment "/ncs:devices/ncs:device/ncs:netconf-notifications/ncs:received-notifications/ncs:notification/ncs:data/tapi-streaming:stream-record/tapi-streaming:log-record/tapi-streaming:log-record-body" {
    when "tapi-streaming:record-content='CONNECTION'" {
      tailf:xpath-root 6;
    }
    // NCS drop if-feature statement
    container connection {
      uses tapi-connectivity:ncs_rpc_notif_connection;
      description
        "none";
    }
    description
      "none";
  }
  augment "/ncs:devices/ncs:device/ncs:notifications/ncs:received-notifications/ncs:notification/ncs:data/tapi-streaming:stream-record/tapi-streaming:log-record/tapi-streaming:log-record-body" {
    when "tapi-streaming:record-content='CONNECTION_END_POINT'" {
      tailf:xpath-root 6;
    }
    // NCS drop if-feature statement
    container connection-end-point {
      uses tapi-connectivity:ncs_rpc_notif_connection-end-point;
      description
        "none";
    }
    description
      "none";
  }
  augment "/ncs:devices/ncs:device/ncs:netconf-notifications/ncs:received-notifications/ncs:notification/ncs:data/tapi-streaming:stream-record/tapi-streaming:log-record/tapi-streaming:log-record-body" {
    when "tapi-streaming:record-content='CONNECTION_END_POINT'" {
      tailf:xpath-root 6;
    }
    // NCS drop if-feature statement
    container connection-end-point {
      uses tapi-connectivity:ncs_rpc_notif_connection-end-point;
      description
        "none";
    }
    description
      "none";
  }
  augment "/ncs:devices/ncs:device/ncs:notifications/ncs:received-notifications/ncs:notification/ncs:data/tapi-streaming:stream-record/tapi-streaming:log-record/tapi-streaming:log-record-body" {
    when "tapi-streaming:record-content='CONNECTIVITY_SERVICE'" {
      tailf:xpath-root 6;
    }
    // NCS drop if-feature statement
    container connectivity-service {
      uses tapi-connectivity:ncs_rpc_notif_connectivity-service;
      description
        "none";
    }
    description
      "none";
  }
  augment "/ncs:devices/ncs:device/ncs:netconf-notifications/ncs:received-notifications/ncs:notification/ncs:data/tapi-streaming:stream-record/tapi-streaming:log-record/tapi-streaming:log-record-body" {
    when "tapi-streaming:record-content='CONNECTIVITY_SERVICE'" {
      tailf:xpath-root 6;
    }
    // NCS drop if-feature statement
    container connectivity-service {
      uses tapi-connectivity:ncs_rpc_notif_connectivity-service;
      description
        "none";
    }
    description
      "none";
  }
  augment "/ncs:devices/ncs:device/ncs:notifications/ncs:received-notifications/ncs:notification/ncs:data/tapi-streaming:stream-record/tapi-streaming:log-record/tapi-streaming:log-record-body" {
    when "tapi-streaming:record-content='CONNECTION_SERVICE_END_POINT'" {
      tailf:xpath-root 6;
    }
    // NCS drop if-feature statement
    container connectivity-service-end-point {
      uses tapi-connectivity:ncs_rpc_notif_connectivity-service-end-point;
      description
        "none";
    }
    description
      "none";
  }
  augment "/ncs:devices/ncs:device/ncs:netconf-notifications/ncs:received-notifications/ncs:notification/ncs:data/tapi-streaming:stream-record/tapi-streaming:log-record/tapi-streaming:log-record-body" {
    when "tapi-streaming:record-content='CONNECTION_SERVICE_END_POINT'" {
      tailf:xpath-root 6;
    }
    // NCS drop if-feature statement
    container connectivity-service-end-point {
      uses tapi-connectivity:ncs_rpc_notif_connectivity-service-end-point;
      description
        "none";
    }
    description
      "none";
  }
  augment "/ncs:devices/ncs:device/ncs:notifications/ncs:received-notifications/ncs:notification/ncs:data/tapi-streaming:stream-record/tapi-streaming:log-record/tapi-streaming:log-record-body" {
    when "tapi-streaming:record-content='ROUTE'" {
      tailf:xpath-root 6;
    }
    // NCS drop if-feature statement
    container route {
      uses tapi-connectivity:ncs_rpc_notif_route;
      description
        "none";
    }
    description
      "none";
  }
  augment "/ncs:devices/ncs:device/ncs:netconf-notifications/ncs:received-notifications/ncs:notification/ncs:data/tapi-streaming:stream-record/tapi-streaming:log-record/tapi-streaming:log-record-body" {
    when "tapi-streaming:record-content='ROUTE'" {
      tailf:xpath-root 6;
    }
    // NCS drop if-feature statement
    container route {
      uses tapi-connectivity:ncs_rpc_notif_route;
      description
        "none";
    }
    description
      "none";
  }
  augment "/ncs:devices/ncs:device/ncs:notifications/ncs:received-notifications/ncs:notification/ncs:data/tapi-streaming:stream-record/tapi-streaming:log-record/tapi-streaming:log-record-body" {
    when "tapi-streaming:record-content='SWITCH'" {
      tailf:xpath-root 6;
    }
    // NCS drop if-feature statement
    container switch {
      uses tapi-connectivity:ncs_rpc_notif_switch;
      description
        "none";
    }
    description
      "none";
  }
  augment "/ncs:devices/ncs:device/ncs:netconf-notifications/ncs:received-notifications/ncs:notification/ncs:data/tapi-streaming:stream-record/tapi-streaming:log-record/tapi-streaming:log-record-body" {
    when "tapi-streaming:record-content='SWITCH'" {
      tailf:xpath-root 6;
    }
    // NCS drop if-feature statement
    container switch {
      uses tapi-connectivity:ncs_rpc_notif_switch;
      description
        "none";
    }
    description
      "none";
  }
  augment "/ncs:devices/ncs:device/ncs:notifications/ncs:received-notifications/ncs:notification/ncs:data/tapi-streaming:stream-record/tapi-streaming:log-record/tapi-streaming:log-record-body" {
    when "tapi-streaming:record-content='SWITCH_CONTROL'" {
      tailf:xpath-root 6;
    }
    // NCS drop if-feature statement
    container switch-control {
      uses tapi-connectivity:ncs_rpc_notif_switch-control;
      description
        "none";
    }
    description
      "none";
  }
  augment "/ncs:devices/ncs:device/ncs:netconf-notifications/ncs:received-notifications/ncs:notification/ncs:data/tapi-streaming:stream-record/tapi-streaming:log-record/tapi-streaming:log-record-body" {
    when "tapi-streaming:record-content='SWITCH_CONTROL'" {
      tailf:xpath-root 6;
    }
    // NCS drop if-feature statement
    container switch-control {
      uses tapi-connectivity:ncs_rpc_notif_switch-control;
      description
        "none";
    }
    description
      "none";
  }
  augment "/ncs:devices/ncs:device/ncs:notifications/ncs:received-notifications/ncs:notification/ncs:data/tapi-streaming:stream-record/tapi-streaming:log-record/tapi-streaming:log-record-body" {
    when "tapi-streaming:record-content='EQUIPMENT'" {
      tailf:xpath-root 6;
    }
    // NCS drop if-feature statement
    container equipment {
      uses tapi-equipment:ncs_rpc_notif_equipment;
      description
        "none";
    }
    description
      "none";
  }
  augment "/ncs:devices/ncs:device/ncs:netconf-notifications/ncs:received-notifications/ncs:notification/ncs:data/tapi-streaming:stream-record/tapi-streaming:log-record/tapi-streaming:log-record-body" {
    when "tapi-streaming:record-content='EQUIPMENT'" {
      tailf:xpath-root 6;
    }
    // NCS drop if-feature statement
    container equipment {
      uses tapi-equipment:ncs_rpc_notif_equipment;
      description
        "none";
    }
    description
      "none";
  }
  augment "/ncs:devices/ncs:device/ncs:notifications/ncs:received-notifications/ncs:notification/ncs:data/tapi-streaming:stream-record/tapi-streaming:log-record/tapi-streaming:log-record-body" {
    when "tapi-streaming:record-content='HOLDER'" {
      tailf:xpath-root 6;
    }
    // NCS drop if-feature statement
    container holder {
      uses tapi-equipment:ncs_rpc_notif_holder;
      description
        "none";
    }
    description
      "none";
  }
  augment "/ncs:devices/ncs:device/ncs:netconf-notifications/ncs:received-notifications/ncs:notification/ncs:data/tapi-streaming:stream-record/tapi-streaming:log-record/tapi-streaming:log-record-body" {
    when "tapi-streaming:record-content='HOLDER'" {
      tailf:xpath-root 6;
    }
    // NCS drop if-feature statement
    container holder {
      uses tapi-equipment:ncs_rpc_notif_holder;
      description
        "none";
    }
    description
      "none";
  }
  augment "/ncs:devices/ncs:device/ncs:notifications/ncs:received-notifications/ncs:notification/ncs:data/tapi-streaming:stream-record/tapi-streaming:log-record/tapi-streaming:log-record-body" {
    when "tapi-streaming:record-content='ACCESS_PORT'" {
      tailf:xpath-root 6;
    }
    // NCS drop if-feature statement
    container access-port {
      uses tapi-equipment:ncs_rpc_notif_access-port;
      description
        "none";
    }
    description
      "none";
  }
  augment "/ncs:devices/ncs:device/ncs:netconf-notifications/ncs:received-notifications/ncs:notification/ncs:data/tapi-streaming:stream-record/tapi-streaming:log-record/tapi-streaming:log-record-body" {
    when "tapi-streaming:record-content='ACCESS_PORT'" {
      tailf:xpath-root 6;
    }
    // NCS drop if-feature statement
    container access-port {
      uses tapi-equipment:ncs_rpc_notif_access-port;
      description
        "none";
    }
    description
      "none";
  }
  augment "/ncs:devices/ncs:device/ncs:notifications/ncs:received-notifications/ncs:notification/ncs:data/tapi-streaming:stream-record/tapi-streaming:log-record/tapi-streaming:log-record-body" {
    when "tapi-streaming:record-content='ABSTRACT_STRAND'" {
      tailf:xpath-root 6;
    }
    // NCS drop if-feature statement
    container abstract-strand {
      uses tapi-equipment:ncs_rpc_notif_abstract-strand;
      description
        "none";
    }
    description
      "none";
  }
  augment "/ncs:devices/ncs:device/ncs:netconf-notifications/ncs:received-notifications/ncs:notification/ncs:data/tapi-streaming:stream-record/tapi-streaming:log-record/tapi-streaming:log-record-body" {
    when "tapi-streaming:record-content='ABSTRACT_STRAND'" {
      tailf:xpath-root 6;
    }
    // NCS drop if-feature statement
    container abstract-strand {
      uses tapi-equipment:ncs_rpc_notif_abstract-strand;
      description
        "none";
    }
    description
      "none";
  }
  augment "/ncs:devices/ncs:device/ncs:notifications/ncs:received-notifications/ncs:notification/ncs:data/tapi-streaming:stream-record/tapi-streaming:log-record/tapi-streaming:log-record-body" {
    when "tapi-streaming:record-content='DEVICE'" {
      tailf:xpath-root 6;
    }
    // NCS drop if-feature statement
    container device {
      uses tapi-equipment:ncs_rpc_notif_device;
      description
        "none";
    }
    description
      "none";
  }
  augment "/ncs:devices/ncs:device/ncs:netconf-notifications/ncs:received-notifications/ncs:notification/ncs:data/tapi-streaming:stream-record/tapi-streaming:log-record/tapi-streaming:log-record-body" {
    when "tapi-streaming:record-content='DEVICE'" {
      tailf:xpath-root 6;
    }
    // NCS drop if-feature statement
    container device {
      uses tapi-equipment:ncs_rpc_notif_device;
      description
        "none";
    }
    description
      "none";
  }
  augment "/ncs:devices/ncs:device/ncs:notifications/ncs:received-notifications/ncs:notification/ncs:data/tapi-streaming:stream-record/tapi-streaming:log-record/tapi-streaming:log-record-body" {
    when "tapi-streaming:record-content='PHYSICAL_SPAN'" {
      tailf:xpath-root 6;
    }
    // NCS drop if-feature statement
    container physical-span {
      uses tapi-equipment:ncs_rpc_notif_physical-span;
      description
        "none";
    }
    description
      "none";
  }
  augment "/ncs:devices/ncs:device/ncs:netconf-notifications/ncs:received-notifications/ncs:notification/ncs:data/tapi-streaming:stream-record/tapi-streaming:log-record/tapi-streaming:log-record-body" {
    when "tapi-streaming:record-content='PHYSICAL_SPAN'" {
      tailf:xpath-root 6;
    }
    // NCS drop if-feature statement
    container physical-span {
      uses tapi-equipment:ncs_rpc_notif_physical-span;
      description
        "none";
    }
    description
      "none";
  }
  augment "/ncs:devices/ncs:device/ncs:notifications/ncs:received-notifications/ncs:notification/ncs:data/tapi-streaming:stream-record/tapi-streaming:log-record/tapi-streaming:log-record-body" {
    when "tapi-streaming:record-content='MEG_END_POINT'" {
      tailf:xpath-root 6;
    }
    // NCS drop if-feature statement
    container mep {
      uses tapi-oam:ncs_rpc_notif_mep;
      description
        "none";
    }
    description
      "none";
  }
  augment "/ncs:devices/ncs:device/ncs:netconf-notifications/ncs:received-notifications/ncs:notification/ncs:data/tapi-streaming:stream-record/tapi-streaming:log-record/tapi-streaming:log-record-body" {
    when "tapi-streaming:record-content='MEG_END_POINT'" {
      tailf:xpath-root 6;
    }
    // NCS drop if-feature statement
    container mep {
      uses tapi-oam:ncs_rpc_notif_mep;
      description
        "none";
    }
    description
      "none";
  }
  augment "/ncs:devices/ncs:device/ncs:notifications/ncs:received-notifications/ncs:notification/ncs:data/tapi-streaming:stream-record/tapi-streaming:log-record/tapi-streaming:log-record-body" {
    when "tapi-streaming:record-content='OAM_JOB'" {
      tailf:xpath-root 6;
    }
    // NCS drop if-feature statement
    container oam-job {
      uses tapi-oam:ncs_rpc_notif_oam-job;
      description
        "none";
    }
    description
      "none";
  }
  augment "/ncs:devices/ncs:device/ncs:netconf-notifications/ncs:received-notifications/ncs:notification/ncs:data/tapi-streaming:stream-record/tapi-streaming:log-record/tapi-streaming:log-record-body" {
    when "tapi-streaming:record-content='OAM_JOB'" {
      tailf:xpath-root 6;
    }
    // NCS drop if-feature statement
    container oam-job {
      uses tapi-oam:ncs_rpc_notif_oam-job;
      description
        "none";
    }
    description
      "none";
  }
  augment "/ncs:devices/ncs:device/ncs:notifications/ncs:received-notifications/ncs:notification/ncs:data/tapi-streaming:stream-record/tapi-streaming:log-record/tapi-streaming:log-record-body" {
    when "tapi-streaming:record-content='MAINTENANCE_ENTITY_GROUP'" {
      tailf:xpath-root 6;
    }
    // NCS drop if-feature statement
    container meg {
      uses tapi-oam:ncs_rpc_notif_meg;
      description
        "none";
    }
    description
      "none";
  }
  augment "/ncs:devices/ncs:device/ncs:netconf-notifications/ncs:received-notifications/ncs:notification/ncs:data/tapi-streaming:stream-record/tapi-streaming:log-record/tapi-streaming:log-record-body" {
    when "tapi-streaming:record-content='MAINTENANCE_ENTITY_GROUP'" {
      tailf:xpath-root 6;
    }
    // NCS drop if-feature statement
    container meg {
      uses tapi-oam:ncs_rpc_notif_meg;
      description
        "none";
    }
    description
      "none";
  }
  augment "/ncs:devices/ncs:device/ncs:notifications/ncs:received-notifications/ncs:notification/ncs:data/tapi-streaming:stream-record/tapi-streaming:log-record/tapi-streaming:log-record-body" {
    when "tapi-streaming:record-content='MEG_INTERMEDIATE_POINT'" {
      tailf:xpath-root 6;
    }
    // NCS drop if-feature statement
    container mip {
      uses tapi-oam:ncs_rpc_notif_mip;
      description
        "none";
    }
    description
      "none";
  }
  augment "/ncs:devices/ncs:device/ncs:netconf-notifications/ncs:received-notifications/ncs:notification/ncs:data/tapi-streaming:stream-record/tapi-streaming:log-record/tapi-streaming:log-record-body" {
    when "tapi-streaming:record-content='MEG_INTERMEDIATE_POINT'" {
      tailf:xpath-root 6;
    }
    // NCS drop if-feature statement
    container mip {
      uses tapi-oam:ncs_rpc_notif_mip;
      description
        "none";
    }
    description
      "none";
  }
  augment "/ncs:devices/ncs:device/ncs:notifications/ncs:received-notifications/ncs:notification/ncs:data/tapi-streaming:stream-record/tapi-streaming:log-record/tapi-streaming:log-record-body" {
    when "tapi-streaming:record-content='OAM_SERVICE'" {
      tailf:xpath-root 6;
    }
    // NCS drop if-feature statement
    container oam-service {
      uses tapi-oam:ncs_rpc_notif_oam-service;
      description
        "none";
    }
    description
      "none";
  }
  augment "/ncs:devices/ncs:device/ncs:netconf-notifications/ncs:received-notifications/ncs:notification/ncs:data/tapi-streaming:stream-record/tapi-streaming:log-record/tapi-streaming:log-record-body" {
    when "tapi-streaming:record-content='OAM_SERVICE'" {
      tailf:xpath-root 6;
    }
    // NCS drop if-feature statement
    container oam-service {
      uses tapi-oam:ncs_rpc_notif_oam-service;
      description
        "none";
    }
    description
      "none";
  }
  augment "/ncs:devices/ncs:device/ncs:notifications/ncs:received-notifications/ncs:notification/ncs:data/tapi-streaming:stream-record/tapi-streaming:log-record/tapi-streaming:log-record-body" {
    when "tapi-streaming:record-content='OAM_SERVICE_END_POINT'" {
      tailf:xpath-root 6;
    }
    // NCS drop if-feature statement
    container oam-service-end-point {
      uses tapi-oam:ncs_rpc_notif_oam-service-end-point;
      description
        "none";
    }
    description
      "none";
  }
  augment "/ncs:devices/ncs:device/ncs:netconf-notifications/ncs:received-notifications/ncs:notification/ncs:data/tapi-streaming:stream-record/tapi-streaming:log-record/tapi-streaming:log-record-body" {
    when "tapi-streaming:record-content='OAM_SERVICE_END_POINT'" {
      tailf:xpath-root 6;
    }
    // NCS drop if-feature statement
    container oam-service-end-point {
      uses tapi-oam:ncs_rpc_notif_oam-service-end-point;
      description
        "none";
    }
    description
      "none";
  }
  augment "/ncs:devices/ncs:device/ncs:notifications/ncs:received-notifications/ncs:notification/ncs:data/tapi-streaming:stream-record/tapi-streaming:log-record/tapi-streaming:log-record-body" {
    when "tapi-streaming:record-content='PM_CURRENT_DATA'" {
      tailf:xpath-root 6;
    }
    // NCS drop if-feature statement
    container pm-current-data {
      uses tapi-oam:ncs_rpc_notif_pm-current-data;
      description
        "none";
    }
    description
      "none";
  }
  augment "/ncs:devices/ncs:device/ncs:netconf-notifications/ncs:received-notifications/ncs:notification/ncs:data/tapi-streaming:stream-record/tapi-streaming:log-record/tapi-streaming:log-record-body" {
    when "tapi-streaming:record-content='PM_CURRENT_DATA'" {
      tailf:xpath-root 6;
    }
    // NCS drop if-feature statement
    container pm-current-data {
      uses tapi-oam:ncs_rpc_notif_pm-current-data;
      description
        "none";
    }
    description
      "none";
  }
  augment "/ncs:devices/ncs:device/ncs:notifications/ncs:received-notifications/ncs:notification/ncs:data/tapi-streaming:stream-record/tapi-streaming:log-record/tapi-streaming:log-record-body" {
    when "tapi-streaming:record-content='PM_HISTORY'" {
      tailf:xpath-root 6;
    }
    // NCS drop if-feature statement
    container pm-history-data {
      uses tapi-oam:ncs_rpc_notif_pm-history-data;
      description
        "none";
    }
    description
      "none";
  }
  augment "/ncs:devices/ncs:device/ncs:netconf-notifications/ncs:received-notifications/ncs:notification/ncs:data/tapi-streaming:stream-record/tapi-streaming:log-record/tapi-streaming:log-record-body" {
    when "tapi-streaming:record-content='PM_HISTORY'" {
      tailf:xpath-root 6;
    }
    // NCS drop if-feature statement
    container pm-history-data {
      uses tapi-oam:ncs_rpc_notif_pm-history-data;
      description
        "none";
    }
    description
      "none";
  }
  augment "/ncs:devices/ncs:device/ncs:notifications/ncs:received-notifications/ncs:notification/ncs:data/tapi-streaming:stream-record/tapi-streaming:log-record/tapi-streaming:log-record-body" {
    when "tapi-streaming:record-content='OAM_PROFILE'" {
      tailf:xpath-root 6;
    }
    // NCS drop if-feature statement
    container oam-profile {
      uses tapi-oam:ncs_rpc_notif_oam-profile;
      description
        "none";
    }
    description
      "none";
  }
  augment "/ncs:devices/ncs:device/ncs:netconf-notifications/ncs:received-notifications/ncs:notification/ncs:data/tapi-streaming:stream-record/tapi-streaming:log-record/tapi-streaming:log-record-body" {
    when "tapi-streaming:record-content='OAM_PROFILE'" {
      tailf:xpath-root 6;
    }
    // NCS drop if-feature statement
    container oam-profile {
      uses tapi-oam:ncs_rpc_notif_oam-profile;
      description
        "none";
    }
    description
      "none";
  }
  augment "/ncs:devices/ncs:device/ncs:notifications/ncs:received-notifications/ncs:notification/ncs:data/tapi-streaming:stream-record/tapi-streaming:log-record/tapi-streaming:log-record-body" {
    when "tapi-streaming:record-content='PM_THRESHOLD_DATA'" {
      tailf:xpath-root 6;
    }
    // NCS drop if-feature statement
    container pm-threshold-data {
      uses tapi-oam:ncs_rpc_notif_pm-threshold-data;
      description
        "none";
    }
    description
      "none";
  }
  augment "/ncs:devices/ncs:device/ncs:netconf-notifications/ncs:received-notifications/ncs:notification/ncs:data/tapi-streaming:stream-record/tapi-streaming:log-record/tapi-streaming:log-record-body" {
    when "tapi-streaming:record-content='PM_THRESHOLD_DATA'" {
      tailf:xpath-root 6;
    }
    // NCS drop if-feature statement
    container pm-threshold-data {
      uses tapi-oam:ncs_rpc_notif_pm-threshold-data;
      description
        "none";
    }
    description
      "none";
  }
  augment "/ncs:devices/ncs:device/ncs:notifications/ncs:received-notifications/ncs:notification/ncs:data/tapi-streaming:stream-record/tapi-streaming:log-record/tapi-streaming:log-record-body" {
    when "tapi-streaming:record-content='PM_BIN_DATA'" {
      tailf:xpath-root 6;
    }
    // NCS drop if-feature statement
    container pm-bin-data {
      uses tapi-oam:ncs_rpc_notif_pm-bin-data;
      description
        "none";
    }
    description
      "none";
  }
  augment "/ncs:devices/ncs:device/ncs:netconf-notifications/ncs:received-notifications/ncs:notification/ncs:data/tapi-streaming:stream-record/tapi-streaming:log-record/tapi-streaming:log-record-body" {
    when "tapi-streaming:record-content='PM_BIN_DATA'" {
      tailf:xpath-root 6;
    }
    // NCS drop if-feature statement
    container pm-bin-data {
      uses tapi-oam:ncs_rpc_notif_pm-bin-data;
      description
        "none";
    }
    description
      "none";
  }
  augment "/ncs:devices/ncs:device/ncs:notifications/ncs:received-notifications/ncs:notification/ncs:data/tapi-streaming:stream-record/tapi-streaming:log-record/tapi-streaming:log-record-body" {
    when "tapi-streaming:record-content='PATH'" {
      tailf:xpath-root 6;
    }
    // NCS drop if-feature statement
    container path {
      uses tapi-path-computation:ncs_rpc_notif_path;
      description
        "none";
    }
    description
      "none";
  }
  augment "/ncs:devices/ncs:device/ncs:netconf-notifications/ncs:received-notifications/ncs:notification/ncs:data/tapi-streaming:stream-record/tapi-streaming:log-record/tapi-streaming:log-record-body" {
    when "tapi-streaming:record-content='PATH'" {
      tailf:xpath-root 6;
    }
    // NCS drop if-feature statement
    container path {
      uses tapi-path-computation:ncs_rpc_notif_path;
      description
        "none";
    }
    description
      "none";
  }
  augment "/ncs:devices/ncs:device/ncs:notifications/ncs:received-notifications/ncs:notification/ncs:data/tapi-streaming:stream-record/tapi-streaming:log-record/tapi-streaming:log-record-body" {
    when "tapi-streaming:record-content='PATH_COMPUTATION_SERVICE'" {
      tailf:xpath-root 6;
    }
    // NCS drop if-feature statement
    container path-computation-service {
      uses tapi-path-computation:ncs_rpc_notif_path-computation-service;
      description
        "none";
    }
    description
      "none";
  }
  augment "/ncs:devices/ncs:device/ncs:netconf-notifications/ncs:received-notifications/ncs:notification/ncs:data/tapi-streaming:stream-record/tapi-streaming:log-record/tapi-streaming:log-record-body" {
    when "tapi-streaming:record-content='PATH_COMPUTATION_SERVICE'" {
      tailf:xpath-root 6;
    }
    // NCS drop if-feature statement
    container path-computation-service {
      uses tapi-path-computation:ncs_rpc_notif_path-computation-service;
      description
        "none";
    }
    description
      "none";
  }
  augment "/ncs:devices/ncs:device/ncs:notifications/ncs:received-notifications/ncs:notification/ncs:data/tapi-streaming:stream-record/tapi-streaming:log-record/tapi-streaming:log-record-body" {
    when "tapi-streaming:record-content='PATH_SERVICE_END_POINT'" {
      tailf:xpath-root 6;
    }
    // NCS drop if-feature statement
    container path-service-end-point {
      uses tapi-path-computation:ncs_rpc_notif_path-service-end-point;
      description
        "none";
    }
    description
      "none";
  }
  augment "/ncs:devices/ncs:device/ncs:netconf-notifications/ncs:received-notifications/ncs:notification/ncs:data/tapi-streaming:stream-record/tapi-streaming:log-record/tapi-streaming:log-record-body" {
    when "tapi-streaming:record-content='PATH_SERVICE_END_POINT'" {
      tailf:xpath-root 6;
    }
    // NCS drop if-feature statement
    container path-service-end-point {
      uses tapi-path-computation:ncs_rpc_notif_path-service-end-point;
      description
        "none";
    }
    description
      "none";
  }
  augment "/ncs:devices/ncs:device/ncs:notifications/ncs:received-notifications/ncs:notification/ncs:data/tapi-streaming:stream-record/tapi-streaming:log-record/tapi-streaming:log-record-body" {
    when "tapi-streaming:record-content='PATH_OPTIMIZATION_CONSTRAINT'" {
      tailf:xpath-root 6;
    }
    // NCS drop if-feature statement
    container path-optimization-constraint {
      uses tapi-path-computation:ncs_rpc_notif_path-optimization-constraint;
      description
        "none";
    }
    description
      "none";
  }
  augment "/ncs:devices/ncs:device/ncs:netconf-notifications/ncs:received-notifications/ncs:notification/ncs:data/tapi-streaming:stream-record/tapi-streaming:log-record/tapi-streaming:log-record-body" {
    when "tapi-streaming:record-content='PATH_OPTIMIZATION_CONSTRAINT'" {
      tailf:xpath-root 6;
    }
    // NCS drop if-feature statement
    container path-optimization-constraint {
      uses tapi-path-computation:ncs_rpc_notif_path-optimization-constraint;
      description
        "none";
    }
    description
      "none";
  }
  augment "/ncs:devices/ncs:device/ncs:notifications/ncs:received-notifications/ncs:notification/ncs:data/tapi-streaming:stream-record/tapi-streaming:log-record/tapi-streaming:log-record-body" {
    when "tapi-streaming:record-content='PATH_OBJECTIVE_FUNCTION'" {
      tailf:xpath-root 6;
    }
    // NCS drop if-feature statement
    container path-objective-function {
      uses tapi-path-computation:ncs_rpc_notif_path-objective-function;
      description
        "none";
    }
    description
      "none";
  }
  augment "/ncs:devices/ncs:device/ncs:netconf-notifications/ncs:received-notifications/ncs:notification/ncs:data/tapi-streaming:stream-record/tapi-streaming:log-record/tapi-streaming:log-record-body" {
    when "tapi-streaming:record-content='PATH_OBJECTIVE_FUNCTION'" {
      tailf:xpath-root 6;
    }
    // NCS drop if-feature statement
    container path-objective-function {
      uses tapi-path-computation:ncs_rpc_notif_path-objective-function;
      description
        "none";
    }
    description
      "none";
  }
  augment "/ncs:devices/ncs:device/ncs:notifications/ncs:received-notifications/ncs:notification/ncs:data/tapi-streaming:stream-record/tapi-streaming:log-record/tapi-streaming:log-record-body" {
    when "tapi-streaming:record-content='LINK'" {
      tailf:xpath-root 6;
    }
    // NCS drop if-feature statement
    container link {
      uses tapi-topology:ncs_rpc_notif_link;
      description
        "none";
    }
    description
      "none";
  }
  augment "/ncs:devices/ncs:device/ncs:netconf-notifications/ncs:received-notifications/ncs:notification/ncs:data/tapi-streaming:stream-record/tapi-streaming:log-record/tapi-streaming:log-record-body" {
    when "tapi-streaming:record-content='LINK'" {
      tailf:xpath-root 6;
    }
    // NCS drop if-feature statement
    container link {
      uses tapi-topology:ncs_rpc_notif_link;
      description
        "none";
    }
    description
      "none";
  }
  augment "/ncs:devices/ncs:device/ncs:notifications/ncs:received-notifications/ncs:notification/ncs:data/tapi-streaming:stream-record/tapi-streaming:log-record/tapi-streaming:log-record-body" {
    when "tapi-streaming:record-content='NODE'" {
      tailf:xpath-root 6;
    }
    // NCS drop if-feature statement
    container node {
      uses tapi-topology:ncs_rpc_notif_node;
      description
        "none";
    }
    description
      "none";
  }
  augment "/ncs:devices/ncs:device/ncs:netconf-notifications/ncs:received-notifications/ncs:notification/ncs:data/tapi-streaming:stream-record/tapi-streaming:log-record/tapi-streaming:log-record-body" {
    when "tapi-streaming:record-content='NODE'" {
      tailf:xpath-root 6;
    }
    // NCS drop if-feature statement
    container node {
      uses tapi-topology:ncs_rpc_notif_node;
      description
        "none";
    }
    description
      "none";
  }
  augment "/ncs:devices/ncs:device/ncs:notifications/ncs:received-notifications/ncs:notification/ncs:data/tapi-streaming:stream-record/tapi-streaming:log-record/tapi-streaming:log-record-body" {
    when "tapi-streaming:record-content='TOPOLOGY'" {
      tailf:xpath-root 6;
    }
    // NCS drop if-feature statement
    container topology {
      uses tapi-topology:ncs_rpc_notif_topology;
      description
        "none";
    }
    description
      "none";
  }
  augment "/ncs:devices/ncs:device/ncs:netconf-notifications/ncs:received-notifications/ncs:notification/ncs:data/tapi-streaming:stream-record/tapi-streaming:log-record/tapi-streaming:log-record-body" {
    when "tapi-streaming:record-content='TOPOLOGY'" {
      tailf:xpath-root 6;
    }
    // NCS drop if-feature statement
    container topology {
      uses tapi-topology:ncs_rpc_notif_topology;
      description
        "none";
    }
    description
      "none";
  }
  augment "/ncs:devices/ncs:device/ncs:notifications/ncs:received-notifications/ncs:notification/ncs:data/tapi-streaming:stream-record/tapi-streaming:log-record/tapi-streaming:log-record-body" {
    when "tapi-streaming:record-content='NODE_EDGE_POINT'" {
      tailf:xpath-root 6;
    }
    // NCS drop if-feature statement
    container node-edge-point {
      uses tapi-topology:ncs_rpc_notif_node-edge-point;
      description
        "none";
    }
    description
      "none";
  }
  augment "/ncs:devices/ncs:device/ncs:netconf-notifications/ncs:received-notifications/ncs:notification/ncs:data/tapi-streaming:stream-record/tapi-streaming:log-record/tapi-streaming:log-record-body" {
    when "tapi-streaming:record-content='NODE_EDGE_POINT'" {
      tailf:xpath-root 6;
    }
    // NCS drop if-feature statement
    container node-edge-point {
      uses tapi-topology:ncs_rpc_notif_node-edge-point;
      description
        "none";
    }
    description
      "none";
  }
  augment "/ncs:devices/ncs:device/ncs:notifications/ncs:received-notifications/ncs:notification/ncs:data/tapi-streaming:stream-record/tapi-streaming:log-record/tapi-streaming:log-record-body" {
    when "tapi-streaming:record-content='RULE'" {
      tailf:xpath-root 6;
    }
    // NCS drop if-feature statement
    container rule {
      uses tapi-topology:ncs_rpc_notif_rule;
      description
        "none";
    }
    description
      "none";
  }
  augment "/ncs:devices/ncs:device/ncs:netconf-notifications/ncs:received-notifications/ncs:notification/ncs:data/tapi-streaming:stream-record/tapi-streaming:log-record/tapi-streaming:log-record-body" {
    when "tapi-streaming:record-content='RULE'" {
      tailf:xpath-root 6;
    }
    // NCS drop if-feature statement
    container rule {
      uses tapi-topology:ncs_rpc_notif_rule;
      description
        "none";
    }
    description
      "none";
  }
  augment "/ncs:devices/ncs:device/ncs:notifications/ncs:received-notifications/ncs:notification/ncs:data/tapi-streaming:stream-record/tapi-streaming:log-record/tapi-streaming:log-record-body" {
    when "tapi-streaming:record-content='NODE_RULE_GROUP'" {
      tailf:xpath-root 6;
    }
    // NCS drop if-feature statement
    container node-rule-group {
      uses tapi-topology:ncs_rpc_notif_node-rule-group;
      description
        "none";
    }
    description
      "none";
  }
  augment "/ncs:devices/ncs:device/ncs:netconf-notifications/ncs:received-notifications/ncs:notification/ncs:data/tapi-streaming:stream-record/tapi-streaming:log-record/tapi-streaming:log-record-body" {
    when "tapi-streaming:record-content='NODE_RULE_GROUP'" {
      tailf:xpath-root 6;
    }
    // NCS drop if-feature statement
    container node-rule-group {
      uses tapi-topology:ncs_rpc_notif_node-rule-group;
      description
        "none";
    }
    description
      "none";
  }
  augment "/ncs:devices/ncs:device/ncs:notifications/ncs:received-notifications/ncs:notification/ncs:data/tapi-streaming:stream-record/tapi-streaming:log-record/tapi-streaming:log-record-body" {
    when "tapi-streaming:record-content='INTER_RULE_GROUP'" {
      tailf:xpath-root 6;
    }
    // NCS drop if-feature statement
    container inter-rule-group {
      uses tapi-topology:ncs_rpc_notif_inter-rule-group;
      description
        "none";
    }
    description
      "none";
  }
  augment "/ncs:devices/ncs:device/ncs:netconf-notifications/ncs:received-notifications/ncs:notification/ncs:data/tapi-streaming:stream-record/tapi-streaming:log-record/tapi-streaming:log-record-body" {
    when "tapi-streaming:record-content='INTER_RULE_GROUP'" {
      tailf:xpath-root 6;
    }
    // NCS drop if-feature statement
    container inter-rule-group {
      uses tapi-topology:ncs_rpc_notif_inter-rule-group;
      description
        "none";
    }
    description
      "none";
  }
  augment "/ncs:devices/ncs:device/ncs:notifications/ncs:received-notifications/ncs:notification/ncs:data/tapi-streaming:stream-record/tapi-streaming:log-record/tapi-streaming:log-record-body" {
    when "tapi-streaming:record-content='NETWORK_TOPOLOGY_SERVICE'" {
      tailf:xpath-root 6;
    }
    // NCS drop if-feature statement
    container network-topology-service {
      uses tapi-topology:ncs_rpc_notif_network-topology-service;
      description
        "none";
    }
    description
      "none";
  }
  augment "/ncs:devices/ncs:device/ncs:netconf-notifications/ncs:received-notifications/ncs:notification/ncs:data/tapi-streaming:stream-record/tapi-streaming:log-record/tapi-streaming:log-record-body" {
    when "tapi-streaming:record-content='NETWORK_TOPOLOGY_SERVICE'" {
      tailf:xpath-root 6;
    }
    // NCS drop if-feature statement
    container network-topology-service {
      uses tapi-topology:ncs_rpc_notif_network-topology-service;
      description
        "none";
    }
    description
      "none";
  }
  augment "/ncs:devices/ncs:device/ncs:notifications/ncs:received-notifications/ncs:notification/ncs:data/tapi-streaming:stream-record/tapi-streaming:log-record/tapi-streaming:log-record-body" {
    when "tapi-streaming:record-content='VIRTUAL_NETWORK_SERVICE'" {
      tailf:xpath-root 6;
    }
    // NCS drop if-feature statement
    container virtual-network-service {
      uses tapi-virtual-network:ncs_rpc_notif_virtual-network-service;
      description
        "none";
    }
    description
      "none";
  }
  augment "/ncs:devices/ncs:device/ncs:netconf-notifications/ncs:received-notifications/ncs:notification/ncs:data/tapi-streaming:stream-record/tapi-streaming:log-record/tapi-streaming:log-record-body" {
    when "tapi-streaming:record-content='VIRTUAL_NETWORK_SERVICE'" {
      tailf:xpath-root 6;
    }
    // NCS drop if-feature statement
    container virtual-network-service {
      uses tapi-virtual-network:ncs_rpc_notif_virtual-network-service;
      description
        "none";
    }
    description
      "none";
  }
  augment "/ncs:devices/ncs:device/ncs:notifications/ncs:received-notifications/ncs:notification/ncs:data/tapi-streaming:stream-record/tapi-streaming:log-record/tapi-streaming:log-record-body" {
    when "tapi-streaming:record-content='VIRTUAL_NETWORK_SERVICE_ENDPOINT'" {
      tailf:xpath-root 6;
    }
    // NCS drop if-feature statement
    container virtual-network-service-end-point {
      uses tapi-virtual-network:ncs_rpc_notif_virtual-network-service-end-point;
      description
        "none";
    }
    description
      "none";
  }
  augment "/ncs:devices/ncs:device/ncs:netconf-notifications/ncs:received-notifications/ncs:notification/ncs:data/tapi-streaming:stream-record/tapi-streaming:log-record/tapi-streaming:log-record-body" {
    when "tapi-streaming:record-content='VIRTUAL_NETWORK_SERVICE_ENDPOINT'" {
      tailf:xpath-root 6;
    }
    // NCS drop if-feature statement
    container virtual-network-service-end-point {
      uses tapi-virtual-network:ncs_rpc_notif_virtual-network-service-end-point;
      description
        "none";
    }
    description
      "none";
  }
  augment "/ncs:devices/ncs:device/ncs:notifications/ncs:received-notifications/ncs:notification/ncs:data/tapi-streaming:stream-record/tapi-streaming:log-record/tapi-streaming:log-record-body" {
    when "tapi-streaming:record-content='VIRTUAL_NETWORK_CONSTRAINT'" {
      tailf:xpath-root 6;
    }
    // NCS drop if-feature statement
    container virtual-network-constraint {
      uses tapi-virtual-network:ncs_rpc_notif_virtual-network-constraint;
      description
        "none";
    }
    description
      "none";
  }
  augment "/ncs:devices/ncs:device/ncs:netconf-notifications/ncs:received-notifications/ncs:notification/ncs:data/tapi-streaming:stream-record/tapi-streaming:log-record/tapi-streaming:log-record-body" {
    when "tapi-streaming:record-content='VIRTUAL_NETWORK_CONSTRAINT'" {
      tailf:xpath-root 6;
    }
    // NCS drop if-feature statement
    container virtual-network-constraint {
      uses tapi-virtual-network:ncs_rpc_notif_virtual-network-constraint;
      description
        "none";
    }
    description
      "none";
  }

  identity CONDITION_DETECTOR_TYPE_EVENT_DETECTOR {
    base CONDITION_DETECTOR_TYPE;
    description
      "A type of detector used for reporting events.";
  }

  identity CONDITION_DETECTOR_TYPE_ALARM_DETECTOR {
    base CONDITION_DETECTOR_TYPE;
    description
      "A type of detector used for reporting problems.
       The underlying raw detector is two state from the perspective of the monitored condition.
       The detector is asymmetric in nature.
       One state indicates that there is a problem and the other state indicates that there is no problem.";
  }

  identity CONDITION_DETECTOR_TYPE {
    description
      "none";
  }

  identity SPREAD_BETWEEN {
    base SPREAD;
    description
      "The event occurred between two stated times.";
  }

  identity SPREAD_AFTER {
    base SPREAD;
    description
      "The event occurred after a particular time.";
  }

  identity SPREAD_BEFORE {
    base SPREAD;
    description
      "The event occurred before a particular time.";
  }

  identity SPREAD_AT {
    base SPREAD;
    description
      "The event occurred at a particular time.";
  }

  identity SPREAD {
    description
      "none";
  }

  identity SOURCE_PRECISION_SYNCHRONIZED {
    base SOURCE_PRECISION;
    description
      "The clock at the event source is appropriately synchroniZed to the timing master.
       The view of time of day at the source should be essentially the same as that at other time-synchronized sources.";
  }

  identity SOURCE_PRECISION_FREE_RUNNING {
    base SOURCE_PRECISION;
    description
      "The clock at the event source is free-running.
       The view of time of day at the source may be significantly different from that at other sources.";
  }

  identity SOURCE_PRECISION_UNKNOWN {
    base SOURCE_PRECISION;
    description
      "The state of the clock at the event source is not known.
       The view of time of day at the source is suspect.";
  }

  identity SOURCE_PRECISION {
    description
      "none";
  }

  identity RECORD_TYPE_TOMBSTONE {
    base RECORD_TYPE;
    description
      "Used in a Compacted log to remove old records and truncate deletion history.
       Is only a LogRecordHeader with no LogRecordBody.";
  }

  identity RECORD_TYPE_DELETE {
    base RECORD_TYPE;
    description
      "The record is about a delete.
       The record may have a LogRecordHeader and a LogRecordBody but no augmented content.
       The entityKey should be sufficient to identify the entity to be deleted.
       Under certain circumstances there may be class content in the LogRecordBody.";
  }

  identity RECORD_TYPE_CREATE_UPDATE {
    base RECORD_TYPE;
    description
      "The record includes a create or update.
       Where there is an update in a non-compacted log the information with be sparse (e.g., a single attribute) and about an entity that is already known.";
  }

  identity RECORD_TYPE {
    description
      "none";
  }

  identity STREAM_STATE_TERMINATED {
    base STREAM_STATE;
    description
      "The stream is essentially no longer available. It will be removed from the AvailableStreams list shortly.";
  }

  identity STREAM_STATE_PAUSED {
    base STREAM_STATE;
    description
      "Although the stream is available it has been paused by the administrator such that the records are being appended to the log but a new client will not receive any events whilst the stream is paused.";
  }

  identity STREAM_STATE_ACTIVE {
    base STREAM_STATE;
    description
      "The stream is operating such that if a client connects records will be provided as per back pressure etc.";
  }

  identity STREAM_STATE_ALIGNING {
    base STREAM_STATE;
    description
      "The log that underpins the stream is aligning with other backend services and hence may not be providing full service.
       If events are provided, they will be completely valid.";
  }

  identity STREAM_STATE {
    description
      "none";
  }

  identity LOG_STORAGE_STRATEGY_FULL_HISTORY_WITH_PERIODIC_BASELINE {
    base LOG_STORAGE_STRATEGY;
    description
      "Provides a history with initial state and periodic/occasional statements of current state at a particular point in time.";
  }

  identity LOG_STORAGE_STRATEGY_FULL_HISTORY {
    base LOG_STORAGE_STRATEGY;
    description
      "Maintains a history from system initiation with no missing records.
       Provides initial state at the beginning of the history";
  }

  identity LOG_STORAGE_STRATEGY_TRUNCATED {
    base LOG_STORAGE_STRATEGY;
    description
      "The log only maintains recent records and disposes of old records.
       This log does not alone enable the client to achieve alignment with current state.";
  }

  identity LOG_STORAGE_STRATEGY_COMPACTED {
    base LOG_STORAGE_STRATEGY;
    description
      "The log uses some mechanism to remove noisy detail whilst enabling the client to achieve eventual consistency (alignment) with current state.";
  }

  identity LOG_STORAGE_STRATEGY {
    description
      "none";
  }

  identity LOG_RECORD_STRATEGY_WHOLE_ENTITY_PERIODIC {
    base LOG_RECORD_STRATEGY;
    description
      "A snapshot of an entity is recorded periodically regardless of whether there has been change or not.";
  }

  identity LOG_RECORD_STRATEGY_CHANGE_ONLY {
    base LOG_RECORD_STRATEGY;
    description
      "Each record only provides a view of the changes that have occurred (on a per entity change basis).
       E.g., the log only includes the attribute that has changed and not other attributes that have not changed.";
  }

  identity LOG_RECORD_STRATEGY_WHOLE_ENTITY_ON_CHANGE {
    base LOG_RECORD_STRATEGY;
    description
      "A record provides a snapshot of a whole entity and a snapshot is taken on each change.
       The record includes all properties and values whether they have changed or not.";
  }

  identity LOG_RECORD_STRATEGY {
    description
      "none";
  }

  identity ALARM_DETECTOR_STATE_CLEAR {
    base ALARM_DETECTOR_STATE;
    description
      "The detector is indicating the operation of the monitored entity is within acceptable bounds with respect to the specific condition measured.
       There may be a requirement for persisted acceptable operation after a problem before clear is declared etc.
       For a Compacted Log solution a CLEAR alarm will be considered as a DELETE ChangeType in the RecordBody.
       Hence a CLEAR will also cause a Tombstone record in a Compacted Log solution.";
  }

  identity ALARM_DETECTOR_STATE_INTERMITTENT {
    base ALARM_DETECTOR_STATE;
    description
      "The detector is indicating the operation of the monitored entity is intermittently not within acceptable bounds with respect to the specific condition measured.
       INTERMITTENT support is optional. Where it is supported there may be a requirement for persisted unacceptable operation after a problem occurs before ACTIVE or INTERMITTENT is declared.";
  }

  identity ALARM_DETECTOR_STATE_ACTIVE {
    base ALARM_DETECTOR_STATE;
    description
      "The detector is indicating the operation of the monitored entity is not within acceptable bounds with respect to the specific condition measured.
       If INTERMITTENT is supported there may be a requirement for persisted unacceptable operation after a problem occurs before ACTIVE is declared. An alternative may be to declare INTERMITTENT.
       Where INTERMITTENT is supported, ACTIVE indicates the stable presence of a problem.";
  }

  identity ALARM_DETECTOR_STATE {
    description
      "none";
  }

  feature tapi-streaming-admin {
    description
      "Support for monitoring of active connections to available streams. Through augmentation of context with stream-admin-context, allows the admin client to get details from monitors of active connections to provide a view of whether the client of the monitored stream is having difficult absorbing the stream. Will usually be used in a tapi context for a stream admin client. Will usually be used together with the tapi-streaming feature so that the stream monitors from one stream could be provided through another stream .";
  }

  feature tapi-streaming {
    description
      "Support for streaming of the information in the specific TAPI context, in terms of stream-records. Through augmentation of context with stream-context, allows the client to determine what specific stream connections are supported and which are currently available to connect to. Offers the ability to identify and use various log strategies and stream connection protocols.";
  }
}
